## ams_version=1.0

Model Main_Adaptive_Distance_Metric_Selection {
    Section INPUT_INTERFACE {
        Section EXCEL_INTERFACE {
            DeclarationSection EXCEL_FILE_INFO {
                StringParameter PSI_Sheet_Name;
                StringParameter PSI_Workbook_Name;
                StringParameter PO_EXCEL_ERR_MESSAGE;
                Parameter PO_EXCEL_STATUS;
            }
            Procedure Read_Data_From_Excel {
                Body: {
                    if (FileSelect(filename : PSI_Workbook_Name, directory : "data/", extension : "*.xlsx", title : "Load excel input file")) then
                    
                    	!PI_WORKBOOK_NAME := "Instance_01.xlsx";
                    	PSI_Sheet_Name := "Points";
                    
                    	PO_EXCEL_STATUS := SpreadSheet::SetActiveSheet(PSI_Workbook_Name, PSI_Sheet_Name );
                    	PO_EXCEL_STATUS := SpreadSheet::RetrieveValue(PSI_Workbook_Name, PI_NUM_POINTS, "C2");
                    	PO_EXCEL_STATUS := SpreadSheet::RetrieveSet(PSI_Workbook_Name, SI_Points, "POINTS[DATA NAME]");
                    	PO_EXCEL_STATUS := SpreadSheet::RetrieveSet(PSI_Workbook_Name, SI_Classes, "POINTS[CLASS NAME]");
                    	PO_EXCEL_STATUS := SpreadSheet::RetrieveSet(PSI_Workbook_Name, SI_Dimensions, "DIMENSIONS");
                    	!PO_EXCEL_STATUS := SpreadSheet::RetrieveTable(PI_WORKBOOK_NAME, PI_Point, "D6:E15", "POINT_INDICES", "DIMENSIONS");
                    	!PO_EXCEL_STATUS := SpreadSheet::RetrieveTable(PI_WORKBOOK_NAME, PI_Class, "D6:E15", "POINT_INDICES", "DIMENSIONS");
                    
                    	PO_EXCEL_STATUS := SpreadSheet::RetrieveParameter(
                    	workbook   : PSI_Workbook_Name ,
                    	Parameter  : PE_Class ,
                    	Range      : "C6:C15" );
                    
                    	PO_EXCEL_STATUS := SpreadSheet::RetrieveTable(
                    		workbook      : PSI_Workbook_Name ,
                    		Parameter     : PI_Point ,
                    		DataRange     : "D6:E15" ,
                    		RowsRange     : "B6:B15" ,
                    		ColumnsRange  : "DIMENSIONS" );
                    
                    	ExcelCloseWorkbook(PSI_Workbook_Name,0); !Close workbook without saving it
                    
                    endif;
                }
            }
        }
        Section TEXT_FILE_INTERFACE;
    }
    Section INPUT_DATA {
        DeclarationSection Input_Set_Declarations {
            Set SI_Points {
                Index: i, j, k;
            }
            Set SI_Classes {
                Index: c;
            }
            Set SI_Dimensions {
                Index: d, d1, d2;
            }
        }
        DeclarationSection Input_Parameter_Declarations {
            Parameter PI_EPSILON;
            Parameter PI_Num_Points;
            Parameter PI_Num_Classes {
                Range: integer;
            }
            Parameter PI_MAX_DISTANCE {
                Range: nonnegative;
                Definition: 1;
            }
            Parameter PI_Class {
                IndexDomain: i;
            }
            Parameter PI_Point {
                IndexDomain: (i,d);
                Text: "A vector in \\Re^d";
                Range: free;
            }
            ElementParameter PE_Class {
                IndexDomain: i;
                Range: SI_Classes;
            }
        }
    }
    Section REFINED_DATA {
        DeclarationSection Refined_Set_Declarations {
            Set SD_Neighbors {
                SubsetOf: (SI_Points,SI_Points);
                Definition: {
                    
                    { (i,j) | i <> j and PE_Class(i) = PE_Class(j) }
                }
            }
            Set SD_Non_Neighbors {
                SubsetOf: (SI_Points,SI_Points);
                Definition: {
                    
                    { (i,j) | PE_Class(i) <> PE_Class(j) }
                }
            }
        }
        DeclarationSection Refined_Parameter_Declarations {
            Parameter PD_Delta {
                IndexDomain: (i,j,d);
                Text: "Coordinate distance between two points";
                Range: free;
                Definition: PI_Point(i,d)-PI_Point(j,d);
            }
            Parameter PD_L2_Norm {
                IndexDomain: i;
                Range: nonnegative;
                Definition: {
                    
                    sqrt( sum[ d , PI_Point(i, d)**2 ] )
                }
            }
            Parameter PD_L2_Distance {
                IndexDomain: (i,j);
                Text: "Euclidean distance between point \'i\' and point \'j\'";
                Range: nonnegative;
                Definition: {
                    
                    sqrt( sum[ d , (PI_Point(i, d)-PI_Point(j, d))^2 ] )
                }
            }
            Parameter PD_L2_Distance_To_Closest_Neighbor {
                IndexDomain: i;
                Range: nonnegative;
                Definition: {
                    
                    min[ j | (i,j) in SD_Neighbors , PD_L2_Distance(i, j) ]
                }
            }
            Parameter PD_L2_Distance_To_Closest_Non_Neighbor {
                IndexDomain: i;
                Range: nonnegative;
                Definition: {
                    
                    min[ k | (i,k) in SD_Non_Neighbors , PD_L2_Distance(i, k) ]
                }
            }
            Parameter PD_L2_Separation {
                IndexDomain: i;
                Text: "Separation (L2 distance) between closest non-neighbor and closest neighbor (may be negative)";
                Range: free;
                Definition: PD_L2_Distance_To_Closest_Non_Neighbor(i) - PD_L2_Distance_To_Closest_Neighbor(i);
            }
            Parameter PD_Min_Coord {
                Range: free;
                Definition: {
                    
                    min[ (i,d) , PI_Point(i, d) ]
                }
            }
            Parameter PD_Max_Coord {
                Range: free;
                Definition: {
                    
                    max[ (i,d) , PI_Point(i, d) ]
                }
            }
        }
    }
    Section MATH_PROGRAMS {
        Section COMMON {
            DeclarationSection Common_Variables {
                Variable VC_Distance {
                    IndexDomain: (i,j) | i <> j;
                    Text: "Distance between point \'i\' and point \'j\'";
                    Range: [0, PI_MAX_DISTANCE];
                    Definition: {
                        sum[ d , PD_Delta(i,j,d)^2 * VC_Q_Coeff(d,d) ]
                        +
                        2*sum[ (d1,d2) | ord(d1) < ord(d2) , PD_Delta(i,j,d1) * PD_Delta(i,j,d2) * VC_Q_Coeff(d1,d2) ]
                    }
                }
                Variable VC_Min_Dist {
                    IndexDomain: i;
                    Range: [0, PI_MAX_DISTANCE];
                }
                Variable VC_Q_Coeff {
                    IndexDomain: (d1,d2) | ord(d1) <= ord(d2);
                    Range: free;
                    Definition: 0$(ord(d1) < ord(d2));
                }
                Variable VC_Separation {
                    IndexDomain: i;
                    Text: "Separation between the nearest neighbor of point \'i\' and its nearest non-neighbor";
                    Range: nonnegative;
                }
                Variable VC_Violation {
                    IndexDomain: i;
                    Range: nonnegative;
                }
            }
            DeclarationSection Common_Constraints;
        }
        Section BIGM_MILP {
            DeclarationSection BIGM_Parameters;
            DeclarationSection BIGM_Variables {
                Variable VB_Is_Nearest_Neighbor_Pair {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Range: binary;
                }
                Variable VC_Bilinear {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Range: [0, PI_MAX_DISTANCE];
                }
                Variable VB_Is_Outlier {
                    IndexDomain: i;
                    Range: binary;
                }
            }
            DeclarationSection BIGM_Constraints {
                Constraint CE_Min_Dist_Definition {
                    IndexDomain: (i,k);
                    Definition: {
                        
                        sum[ j | (i,j) in SD_Neighbors , VC_Bilinear(i, j) ]
                        +
                        VC_Min_Dist(i)
                        =
                        VC_Distance(i, k)
                        +
                        VB_Is_Outlier(i)
                    }
                }
                Constraint CL_McCormick1 {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Definition: {
                        
                        VC_Bilinear(i, j) <= VC_Distance(i, j)
                    }
                }
                Constraint CL_McCormick2 {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Definition: {
                        
                        VC_Bilinear(i, j) <= VB_Is_Nearest_Neighbor_Pair(i, j)
                    }
                }
                Constraint CG_McCormick3 {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Definition: {
                        
                        VC_Bilinear(i, j) >=  VC_Distance(i, j) + VB_Is_Nearest_Neighbor_Pair(i, j) - 1
                    }
                }
                Constraint CE_Select_At_Most_One_Neighbor {
                    IndexDomain: i;
                    Definition: {
                        
                        sum[ j | (i,j) in SD_Neighbors , VB_Is_Nearest_Neighbor_Pair(i, j) ] = 1 - VB_Is_Outlier(i)
                    }
                }
            }
            DeclarationSection BIGM_MP;
        }
        Section FEASIBILITY_LP {
            DeclarationSection Feasibility_LP_Variables {
                Variable VC_Objval_Max_Dist_To_Nearest_Non_Neighbor {
                    Range: free;
                    Definition: {
                        
                        sum[ i, VC_Min_Dist(i) ]
                    }
                }
            }
            DeclarationSection Feasiblity_LP_Constraints {
                Constraint CL_Min_Dist_LEQ_All_Neighbors {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Definition: {
                        
                        VC_Min_Dist(i) <= VC_Distance(i,j)
                    }
                }
                Constraint CL_Max_Min_Dist_To_Nearest_Non_Neighbor {
                    IndexDomain: (i,k) | (i,k) in SD_Non_Neighbors;
                    Definition: {
                        
                        VC_Min_Dist(i) + PI_EPSILON <= VC_Distance(i,k)
                    }
                }
            }
            DeclarationSection Feasibility_LP_MP {
                MathematicalProgram MP_Feasibility_LP {
                    Objective: VC_Objval_Max_Dist_To_Nearest_Non_Neighbor;
                    Direction: maximize;
                    Constraints: SD_Feasibility_LP_Constraints;
                    Variables: SD_Feasibility_LP_Variables;
                    Type: LP;
                }
                Set SD_Feasibility_LP_Variables {
                    SubsetOf: AllVariables;
                    Definition: AllVariables * (COMMON + FEASIBILITY_LP);
                }
                Set SD_Feasibility_LP_Constraints {
                    SubsetOf: AllConstraints;
                    Definition: AllConstraints * (COMMON + FEASIBILITY_LP);
                }
            }
        }
    }
    Section HEURISTICS {
        Procedure Solve_Feasibility_LP {
            Body: {
                Solve MP_Feasibility_LP;
            }
        }
        Procedure Proc_Feasibility_LP_Loop {
            Body: {
                
                !!! ASSIGNMENT
            }
        }
    }
    Section INSTANCE_GENERATOR {
        Procedure Proc_Save_Instance {
            Body: {
                Instance_File.pagewidth := PI_Pagewidth;
                
                !PS_Current_Date_And_Time := CurrentToString("%m%d%H%M");
                PS_Instance_Name_Only := "Clustering_instance" + "_P" + PI_Num_Points + "_C" + PI_Num_Classes + "_D" + Card(SI_Dimensions) + ".txt";
                PS_Instance_File := PS_Instance_Directory + PS_Instance_Name_Only;
                
                put Instance_File;
                
                display SI_Points, SI_Classes, SI_Dimensions;
                display PE_Class;
                display PI_Point;
                
                putclose Instance_File;
            }
        }
        DeclarationSection Save_Instance_Declaration {
            File Instance_File {
                Name: PS_Instance_File;
                Device: Disk;
                Mode: replace;
            }
            StringParameter PS_Instance_File;
            StringParameter PS_Instance_Directory {
                Definition: "data/text_instances/";
            }
            StringParameter PS_Instance_Name_Only;
            Parameter PI_Pagewidth {
                Definition: 70;
            }
        }
        Parameter PI_Outlier_Probability {
            Range: [0, 1];
            InitialData: 0;
        }
        Parameter PI_Noise {
            Range: [0, 1];
            InitialData: 0;
        }
        DeclarationSection NOTE {
            Comment: {
                "Consider adding a function to generate more points to an already generated instance.
                
                What are the steps one would take?
                (1) Attempt to use Euclidean distance
                (2) If Euclidean distance is not suitable (leads to outliers), modify the distance metric
                (3) Using a PWL function with a constant penalty for outliers,
                vary the penalty constant from small to large to see how the distance metrics perform
                User inputs the range of the penalty parameter, e.g.,
                -1 to -10 by 1"
            }
        }
        Section ANNULUS_2D {
            Procedure Proc_Generate_Random_Instance_Annulus_2D {
                Body: {
                    !PI_NUM_POINTS := 200;
                    !PI_Num_Classes_Annulus2d := 4;
                    SI_Classes := ElementRange(
                    	From    :  1,
                    	To      :  PI_Num_Classes,
                    	Incr    :  1,
                    	Prefix  :  'c',
                    	Fill    :  1);
                    SI_Dimensions := {'d1','d2'};
                    SI_Points := ElementRange(1,PI_NUM_POINTS);  ! {1 .. PI_NUM_POINTS};
                    
                    !PI_Outlier_Probability := 0.0;
                    P_Radius_Noise := PI_Noise;
                    
                    for i do
                    	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    	P_Angle := radians(360*Uniform(0,1)); ! Generate random 2D angle
                    	P_Radius := ord(PE_Class(i)) - P_Radius_Noise/2 + P_Radius_Noise*Uniform(0,1);
                    	PI_Point(i, 'd1') := P_Radius*cos(P_Angle);
                    	PI_Point(i, 'd2') := P_Radius*sin(P_Angle);
                    	if ( PI_Outlier_Probability > 0 ) then
                    		if ( Uniform(0,1) < PI_Outlier_Probability ) then
                    			PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes)));
                    		endif;
                    	endif;
                    endfor;
                }
                Parameter PI_Num_Points_Annulus2d;
                Parameter PI_Num_Classes_Annulus2d {
                    Range: integer;
                }
                Parameter P_Angle;
                Parameter P_Radius {
                    Range: nonnegative;
                }
                Parameter P_Radius_Noise {
                    Range: nonnegative;
                }
            }
        }
        Section HEART_2D {
            Procedure Proc_Generate_Random_Instance_Heart_2D {
                Body: {
                    !PI_NUM_POINTS := 200;
                    !PI_Num_Classes_Annulus2d := 4;
                    SI_Classes := ElementRange(
                    	From    :  1,
                    	To      :  PI_Num_Classes,
                    	Incr    :  1,
                    	Prefix  :  'c',
                    	Fill    :  1);
                    SI_Dimensions := {'d1','d2'};
                    SI_Points := ElementRange(1,PI_NUM_POINTS);  ! {1 .. PI_NUM_POINTS};
                    P_Denom := 16;
                    
                    for i do
                    	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    
                    	PI_t := radians(360*Uniform(0,1));
                    
                    !	P_Angle := radians(360*Uniform(0,1)); ! Generate random 2D angle
                    	P_Int := ord(PE_Class(i)); ! - P_Radius_Noise/2 + P_Radius_Noise*Uniform(0,1);
                    
                    	PI_Point(i, 'd1') := (P_Int/P_Denom)*( 16*(sin(PI_t))^3 ) - PI_Noise/2 + PI_Noise*Uniform(0,1);
                    	PI_Point(i, 'd2') := (P_Int/P_Denom)*( 13*cos(PI_t) - 5*cos(2*PI_t) - 2*cos(3*PI_t) - cos(4*PI_t) ) - PI_Noise/2 + PI_Noise*Uniform(0,1);;
                    
                    	if ( PI_Outlier_Probability > 0 ) then
                    		if ( Uniform(0,1) < PI_Outlier_Probability ) then
                    			PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes)));
                    		endif;
                    	endif;
                    endfor;
                }
                Parameter PI_Num_Points_Annulus2d;
                Parameter PI_Num_Classes_Annulus2d {
                    Range: integer;
                }
                Parameter P_Int;
                Parameter PI_t;
                Parameter P_Denom;
            }
        }
        Section STAR_2D {
            Procedure Proc_Generate_Random_Instance_Star_2D {
                Body: {
                    !PI_NUM_POINTS := 200;
                    !PI_Num_Classes_Annulus2d := 4;
                    SI_Classes := ElementRange(
                    	From    :  1,
                    	To      :  PI_Num_Classes,
                    	Incr    :  1,
                    	Prefix  :  'c',
                    	Fill    :  1);
                    SI_Dimensions := {'d1','d2'};
                    SI_Points := ElementRange(1,PI_NUM_POINTS);  ! {1 .. PI_NUM_POINTS};
                    
                    !PI_Outlier_Probability := 0.0;
                    P_Radius_Noise := PI_Noise;
                    
                    for i do
                    	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    	P_Angle := radians(360*Uniform(0,1)); ! Generate random 2D angle
                    	P_Radius := ord(PE_Class(i)) - P_Radius_Noise/2 + P_Radius_Noise*Uniform(0,1);
                    	PI_Point(i, 'd1') := P_Radius*cos(P_Angle);
                    	PI_Point(i, 'd2') := P_Radius*sin(P_Angle);
                    
                    	if ( P_Angle < radians(90) ) then
                    		PI_Point(i, 'd1') -= P_Radius;
                    		PI_Point(i, 'd2') -= P_Radius;
                    	elseif ( radians(90) <= P_Angle and P_Angle < radians(180) ) then
                    		PI_Point(i, 'd1') += P_Radius;
                    		PI_Point(i, 'd2') -= P_Radius;
                    	elseif ( radians(180) <= P_Angle and P_Angle <= radians(270) ) then
                    		PI_Point(i, 'd1') += P_Radius;
                    		PI_Point(i, 'd2') += P_Radius;
                    	else
                    		PI_Point(i, 'd1') -= P_Radius;
                    		PI_Point(i, 'd2') += P_Radius;
                    	endif;
                    
                    	if ( PI_Outlier_Probability > 0 ) then
                    		if ( Uniform(0,1) < PI_Outlier_Probability ) then
                    			PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes)));
                    		endif;
                    	endif;
                    endfor;
                }
                Parameter PI_Num_Points_Annulus2d;
                Parameter PI_Num_Classes_Annulus2d {
                    Range: integer;
                }
                Parameter P_Angle;
                Parameter P_Radius {
                    Range: nonnegative;
                }
                Parameter P_Radius_Noise {
                    Range: nonnegative;
                }
            }
        }
        Section SQUARES_2D {
            Procedure Proc_Generate_Random_Instance_Squares_2D {
                Body: {
                    SI_Classes := ElementRange(
                    	From    :  1,
                    	To      :  PI_Num_Classes,
                    	Incr    :  1,
                    	Prefix  :  'c',
                    	Fill    :  1);
                    SI_Dimensions := {'d1','d2'};
                    SI_Points := ElementRange(1,PI_NUM_POINTS);  ! {1 .. PI_NUM_POINTS};
                    
                    for i do
                    	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    	P_Int := ord(PE_Class(i));
                    	P_Sign := -1;
                    	P_Sign$(Uniform(0,1)<0.5) := 1;
                    	if ( Uniform(0,1) < 0.5 ) then
                    		PI_Point(i, 'd1') := P_Sign*P_Int - PI_Noise/2 + PI_Noise*Uniform(0,1);
                    		PI_Point(i, 'd2') := -P_Int + 2*P_Int*Uniform(0,1);
                    	else
                    		PI_Point(i, 'd1') := -P_Int + 2*P_Int*Uniform(0,1);
                    		PI_Point(i, 'd2') := P_Sign*P_Int - PI_Noise/2 + PI_Noise*Uniform(0,1);
                    	endif;
                    	if ( PI_Outlier_Probability > 0 ) then
                    		if ( Uniform(0,1) < PI_Outlier_Probability ) then
                    			PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes)));
                    		endif;
                    	endif;
                    endfor;
                }
                Parameter P_Sign;
                Parameter P_Int;
            }
        }
        Section DIAMONDS_2D {
            Procedure Proc_Generate_Random_Instance_Diamonds_2D {
                Body: {
                    SI_Classes := ElementRange(
                    	From    :  1,
                    	To      :  PI_Num_Classes,
                    	Incr    :  1,
                    	Prefix  :  'c',
                    	Fill    :  1);
                    SI_Dimensions := {'d1','d2'};
                    SI_Points := ElementRange(1,PI_NUM_POINTS);  ! {1 .. PI_NUM_POINTS};
                    
                    for i do
                    	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    	P_Int := ord(PE_Class(i));
                    	P_Slope_Sign := -1;
                    	P_Slope_Sign$(Uniform(0,1)<0.5) := 1;
                    	P_Intercept_Sign := -1;
                    	P_Intercept_Sign$(Uniform(0,1)<0.5) := 1;
                    
                    	PI_Point(i, 'd1') := P_Slope_Sign*P_Int*Uniform(0,1) - PI_Noise/2 + PI_Noise*Uniform(0,1);
                    	PI_Point(i, 'd2') := P_Intercept_Sign*P_Int - P_Intercept_Sign*P_Slope_Sign*PI_Point(i, 'd1')  - PI_Noise/2 + PI_Noise*Uniform(0,1);
                    
                    	if ( PI_Outlier_Probability > 0 ) then
                    		if ( Uniform(0,1) < PI_Outlier_Probability ) then
                    			PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes)));
                    		endif;
                    	endif;
                    endfor;
                }
                Parameter P_Slope_Sign;
                Parameter P_Intercept_Sign;
                Parameter P_Int;
            }
        }
        Section SINUSOIDS_2D {
            Procedure Proc_Generate_Random_Instance_Sinusoids_2D {
                Body: {
                    !PI_NUM_POINTS := 200;
                    !PI_Num_Classes_Annulus2d := 4;
                    SI_Classes := ElementRange(
                    	From    :  1,
                    	To      :  PI_Num_Classes,
                    	Incr    :  1,
                    	Prefix  :  'c',
                    	Fill    :  1);
                    SI_Dimensions := {'d1','d2'};
                    SI_Points := ElementRange(1,PI_NUM_POINTS);  ! {1 .. PI_NUM_POINTS};
                    
                    !PI_Outlier_Probability := 0.0;
                    P_Y_Noise := PI_Noise;
                    
                    for i do
                    	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    	PI_Point(i, 'd1') := radians(360*Uniform(0,1));
                    	PI_Point(i, 'd2') := ord(PE_Class(i)) + sin(PI_Point(i, 'd1')) + P_Y_Noise*Uniform(0,1) - P_Y_Noise/2;
                    
                    	if ( PI_Outlier_Probability > 0 ) then
                    		if ( Uniform(0,1) < PI_Outlier_Probability ) then
                    			PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes)));
                    		endif;
                    	endif;
                    endfor;
                }
            }
            Parameter PI_Intercept {
                IndexDomain: c;
            }
            Parameter P_Y_Noise;
        }
        Section GMP_RANDOM_2D {
            Procedure Proc_Generate_Random_Instance_2D {
                Body: {
                    SI_Classes := ElementRange(
                    	From    :  1,
                    	To      :  PI_Num_Classes,
                    	Incr    :  1,
                    	Prefix  :  'c',
                    	Fill    :  1);
                    SI_Dimensions := {'d1','d2'};
                    SI_Points := ElementRange(1,PI_NUM_POINTS);  ! {1 .. PI_NUM_POINTS};
                    
                    for i do
                    	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    	PI_Point(i, 'd1') := 10*Uniform(0,1);
                    	PI_Point(i, 'd2') := 10*Uniform(0,1);
                    endfor;
                }
            }
        }
    }
    Section PLOTTING {
        Procedure Proc_Temp_Get_Outliers {
            Body: {
                !PO_Is_Outlier(i) := 0;
                !PO_Is_Outlier(i)$( PD_L2_Separation(i) < 0 ) := 1;
            }
        }
        Set SI_My_Colors {
            SubsetOf: AllColors;
            Index: i_color;
            OrderBy: User;
            Definition: {
                data{
                'blue'  ,
                'red'   ,
                'dark green' ,
                'grey'  ,
                'green' ,
                'orange' ,
                'pink' ,
                'yellow' ,
                'royal blue' ,
                'magenta' ,
                'cyan' ,
                'navy blue' ,
                'light grey' ,
                'dark grey' ,
                'yukon yellow' ,
                'icelandic brown' ,
                'quebec pink' ,
                'pygmy maroon' ,
                'carolina blue' ,
                'pygmy pink' ,
                'mexican purple' ,
                'dark cyan' ,
                'hawaiian grey' ,
                'yemeni blue' ,
                'pygmy yellow' ,
                'venezuelan brown' ,
                'ugandan pink'
                }
            }
        }
        ElementParameter PE_Class_Color {
            IndexDomain: c;
            Range: SI_My_Colors;
            Definition: {
                
                Element(SI_My_Colors,ord(c))
            }
        }
        ElementParameter PE_Color {
            IndexDomain: i;
            Range: SI_My_Colors;
            Definition: {
                
                PE_Class_Color( PE_Class(i) )
            }
        }
        Parameter PI_X_Coord {
            IndexDomain: i;
            Range: free;
            Definition: {
                
                PI_Point(i, First(SI_Dimensions))
            }
        }
        Parameter PI_Y_Coord {
            IndexDomain: i;
            Range: free;
            Definition: {
                
                PI_Point(i, Last(SI_Dimensions))
            }
        }
        Set SI_My_Shapes {
            Index: i_shape;
            OrderBy: User;
            Definition: {
                data{
                'x'  ,
                'o'  ,
                '.'  ,
                '-'  ,
                '^'  ,
                '*'
                }
            }
        }
        ElementParameter PE_Class_Shape {
            IndexDomain: c;
            Range: SI_My_Shapes;
            Definition: {
                
                Element(SI_My_Shapes,ord(c))
            }
        }
        ElementParameter PE_Shape {
            IndexDomain: i;
            Range: SI_My_Shapes;
            Definition: {
                
                PE_Class_Shape( PE_Class(i) )
            }
        }
        StringParameter PS_Shape {
            IndexDomain: i;
            Definition: {
                
                PE_Shape(i)
            }
        }
        Parameter PI_Node_Size {
            Range: integer;
            InitialData: 10;
        }
        DeclarationSection Plotting_Declarations_with_Solution {
            Set SD_Outlier_Points {
                SubsetOf: SI_Points;
                Index: i_outlier;
                Definition: {
                    
                    { i | PO_Is_Outlier(i) }
                }
            }
            Set SD_Non_Outlier_Points {
                SubsetOf: SI_Points;
                Index: i_non_outlier;
                Definition: {
                    
                    SI_Points - SD_Outlier_Points
                }
            }
            Set SD_Outlier_Arcs {
                SubsetOf: (SD_Outlier_Points,SI_Points);
                Definition: {
                    
                    { (i_outlier,j) | j = argmin[ k | (i_outlier,k) in SD_Non_Neighbors , PD_L2_Distance(i_outlier, k) ] }
                }
            }
            ElementParameter PE_Outlier_Color {
                Range: AllColors;
                Definition: 'black';
            }
            ElementParameter PE_Solution_Color {
                IndexDomain: i;
                Range: SI_My_Colors;
                Definition: {
                    PE_Class_Color( PE_Class(i) )
                    
                    !if ( not PO_Is_Outlier(i) ) then
                    !	PE_Class_Color( PE_Class(i) )
                    !else
                    !	PE_Outlier_Color
                    !endif;
                }
            }
            Parameter PO_VB_Is_Outlier {
                IndexDomain: i;
                Range: binary;
                Definition: {
                    
                    round( VB_Is_Outlier(i) )
                }
            }
            Parameter PO_Is_Outlier {
                IndexDomain: i;
                Range: binary;
                Definition: {
                    if ( PD_L2_Separation(i) < 0 ) then
                    	1
                    else
                    	0
                    endif;
                }
            }
            Parameter PI_Outlier_Node_Size {
                Range: integer;
                Definition: PI_Node_Size + 5;
            }
            Parameter PD_Solution_Node_Size {
                IndexDomain: i;
                Range: integer;
                Definition: {
                    if ( not PO_Is_Outlier(i) ) then
                    	PI_Node_Size
                    else
                    	PI_Outlier_Node_Size
                    endif;
                }
            }
        }
        DeclarationSection Objective_Function_Options {
            Set SD_Separation_Values {
                Definition: {
                    
                    {
                    -1.0,
                    -0.9,
                    -0.8,
                    -0.7,
                    -0.6,
                    -0.5,
                    -0.4,
                    -0.3,
                    -0.2,
                    -0.1,
                    -0.09,
                    0.01,
                    0.02,
                    0.03,
                    0.04,
                    0.05,
                    0.06,
                    0.07,
                    0.08,
                    0.09,
                    0.1,
                    0.2,
                    0.3,
                    0.4,
                    0.5,
                    0.6,
                    0.7,
                    0.8,
                    0.9,
                    1.0
                    }
                }
            }
            Set SQS {
                SubsetOf: Integers;
                Index: i_sep_incr;
                Definition: {
                    
                    ElementRange(1,201);
                }
            }
            Parameter PI_X_Axis_Plot_Objval {
                IndexDomain: i_sep_incr;
                Definition: {
                    
                    -1 + 0.01*(i_sep_incr-1)
                }
            }
            Parameter PD_Y_Axis_Plot_Objval_Tanh {
                IndexDomain: i_sep_incr;
                Definition: {
                    
                    !-0.5 + 1/(1+exp(-PI_X_Axis_Plot_Objval(i_sep_incr)))
                    tanh(4*PI_X_Axis_Plot_Objval(i_sep_incr))
                }
            }
            Parameter PD_Y_Axis_Plot_Objval_PWL {
                IndexDomain: i_sep_incr;
                Definition: {
                    if ( PI_X_Axis_Plot_Objval(i_sep_incr) < 0 ) then
                    	-1
                    else
                    	PI_X_Axis_Plot_Objval(i_sep_incr)
                    endif;
                }
            }
            Parameter PD_Y_Axis_Plot_Objval_PWL2 {
                IndexDomain: i_sep_incr;
                Definition: {
                    if ( PI_X_Axis_Plot_Objval(i_sep_incr) < 0 ) then
                    	-1
                    elseif ( 0 <= PI_X_Axis_Plot_Objval(i_sep_incr) and PI_X_Axis_Plot_Objval(i_sep_incr) < 0.5 ) then
                    	PI_X_Axis_Plot_Objval(i_sep_incr)
                    else
                    	0.5
                    endif;
                }
            }
        }
    }
    Section UTILS {
        Procedure Proc_Normalize_Data {
            Body: {
                
                PI_Point(i, d) := ( PI_Point(i, d) - PD_Min_Coord ) / ( PD_Max_Coord - PD_Min_Coord )
            }
        }
    }
    Module TempModule {
        Prefix: tm;
        Section Section_1 {
            Procedure Solve_MP1 {
                Body: {
                    solve MP1;
                }
            }
            Procedure Get_presolved_model {
                Body: {
                    PE_GMP_MP1 := GMP::Instance::Generate( MP1 );
                    PE_GMP_MP1_Presolved := GMP::Instance::CreatePresolved( PE_GMP_MP1 , "Presolved_MP1_Model" );
                    PD_Num_Rows_Presolved := GMP::Instance::GetNumberOfRows( PE_GMP_MP1_Presolved );
                    PD_Num_Cols_Presolved := GMP::Instance::GetNumberOfColumns( PE_GMP_MP1_Presolved );
                    !GMP::Instance::GetSymbolicMathematicalProgram
                }
            }
            Set SI_N {
                SubsetOf: Integers;
                Index: j;
                Definition: {
                    {1,2}
                }
            }
            Variable x {
                IndexDomain: j;
                Range: nonnegative;
            }
            Variable objval {
                Range: free;
                Definition: 2*x(1) + x(2);
            }
            Constraint Constraint1 {
                Definition: x(1) + x(2) <= 1;
            }
            Constraint Constraint2 {
                Definition: x(1) + x(2) <= 10;
            }
            MathematicalProgram MP1 {
                Objective: objval;
                Direction: maximize;
                Constraints: SD_Temp_Constraints;
                Variables: SD_Temp_Variables;
                Type: Automatic;
            }
            Set SD_Temp_Variables {
                SubsetOf: AllVariables;
                Definition: AllVariables * Section_1;
            }
            Set SD_Temp_Constraints {
                SubsetOf: AllConstraints;
                Definition: AllConstraints * Section_1;
            }
            ElementParameter PE_GMP_MP1 {
                Range: AllGeneratedMathematicalPrograms;
            }
            ElementParameter PE_GMP_MP1_Presolved {
                Range: AllGeneratedMathematicalPrograms;
            }
            Parameter PD_Num_Rows_Presolved;
            Parameter PD_Num_Cols_Presolved;
        }
    }
    Procedure MainInitialization {
        Body: {
            !SI_Points := {1,2};
            !SI_Classes := {1};
            !SI_Dimension := {1,2};
            !
            !PI_Point(i,d) := ord(d)-1;
            
            !(1,1), (1,0), (2,2) , (2,0),
        }
    }
    Procedure MainExecution;
    Procedure MainTermination {
        Body: {
            return DataManagementExit();
        }
    }
}
