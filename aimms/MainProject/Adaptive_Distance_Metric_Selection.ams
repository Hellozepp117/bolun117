## ams_version=1.0

Model Main_Adaptive_Distance_Metric_Selection {
    Section INPUT_INTERFACE {
        Section EXCEL_INTERFACE {
            DeclarationSection EXCEL_FILE_INFO {
                StringParameter PSI_Sheet_Name;
                StringParameter PSI_Workbook_Name;
                StringParameter PO_EXCEL_ERR_MESSAGE;
                Parameter PO_EXCEL_STATUS;
            }
            Procedure Read_Data_From_Excel {
                Body: {
                    if (FileSelect(filename : PSI_Workbook_Name, directory : "data/", extension : "*.xlsx", title : "Load excel input file")) then
                    
                    	!PI_WORKBOOK_NAME := "Instance_01.xlsx";
                    	PSI_Sheet_Name := "Points";
                    
                    	PO_EXCEL_STATUS := SpreadSheet::SetActiveSheet(PSI_Workbook_Name, PSI_Sheet_Name );
                    	PO_EXCEL_STATUS := SpreadSheet::RetrieveValue(PSI_Workbook_Name, PI_NUM_POINTS, "C2");
                    	PO_EXCEL_STATUS := SpreadSheet::RetrieveSet(PSI_Workbook_Name, SI_Points, "POINTS[DATA NAME]");
                    	PO_EXCEL_STATUS := SpreadSheet::RetrieveSet(PSI_Workbook_Name, SI_Classes, "POINTS[CLASS NAME]");
                    	PO_EXCEL_STATUS := SpreadSheet::RetrieveSet(PSI_Workbook_Name, SI_Dimensions, "DIMENSIONS");
                    	!PO_EXCEL_STATUS := SpreadSheet::RetrieveTable(PI_WORKBOOK_NAME, PI_Point, "D6:E15", "POINT_INDICES", "DIMENSIONS");
                    	!PO_EXCEL_STATUS := SpreadSheet::RetrieveTable(PI_WORKBOOK_NAME, PI_Class, "D6:E15", "POINT_INDICES", "DIMENSIONS");
                    
                    	PO_EXCEL_STATUS := SpreadSheet::RetrieveParameter(
                    	workbook   : PSI_Workbook_Name ,
                    	Parameter  : PE_Class ,
                    	Range      : "C6:C15" );
                    
                    	PO_EXCEL_STATUS := SpreadSheet::RetrieveTable(
                    		workbook      : PSI_Workbook_Name ,
                    		Parameter     : PI_Point ,
                    		DataRange     : "D6:E15" ,
                    		RowsRange     : "B6:B15" ,
                    		ColumnsRange  : "DIMENSIONS" );
                    
                    	ExcelCloseWorkbook(PSI_Workbook_Name,0); !Close workbook without saving it
                    
                    endif;
                }
            }
        }
        Section TEXT_FILE_INTERFACE {
            StringParameter PSI_TEXTFILE_NAME;
            Procedure Proc_Read_Instance_From_Text_File {
                Body: {
                    if (FileSelect(filename : PSI_TEXTFILE_NAME, directory : "data/", extension : "*.txt", title : "Load text input file")) then
                    
                    	empty INPUT_DATA;
                    	read from file PSI_TEXTFILE_NAME;
                    
                    endif;
                }
            }
        }
    }
    Section INPUT_DATA {
        DeclarationSection Input_Set_Declarations {
            Set SI_Points_N_minus_O {
                SubsetOf: SI_Points;
                Index: i_N_O, j_N_O, k_N_O;
                Definition: SI_Points-SI_Points_Outliers;
            }
            Set SI_Points {
                Index: i, j, k;
            }
            Set SI_Points_Active {
                SubsetOf: SI_Points;
                Index: i_a, j_a, k_a;
            }
            Set SI_Points_Active_NonOutliers {
                SubsetOf: SI_Points_Active;
                Index: i_a_n, j_a_n, k_a_n;
            }
            Set SI_Points_Outliers {
                SubsetOf: SI_Points;
                Index: i_out, j_out, k_out;
            }
            Set SI_Points_Outliers_Ri {
                SubsetOf: SI_Points;
            }
            Set SI_Points_Outliers_1 {
                SubsetOf: SI_Points_Outliers;
                Index: i_out_1, j_out_1, k_out_1;
            }
            Set SI_Points_Outliers_2 {
                SubsetOf: SI_Points_Outliers;
                Index: i_out_2, j_out_2, k_out_2;
            }
            Set SI_Classes {
                Index: c;
            }
            Set SI_Dimensions {
                Index: d, d1, d2;
            }
            Set SI_New_Points {
                SubsetOf: SI_Points;
                Index: i_new;
            }
        }
        DeclarationSection Input_Parameter_Declarations {
            Parameter PI_Store_EPSILON {
                IndexDomain: i_Ri;
            }
            Parameter PI_EPSILON;
            Parameter PI_Num_Points;
            Parameter PI_Num_New_Points;
            Parameter PI_Num_Classes {
                Range: integer;
            }
            Parameter PI_MAX_DISTANCE {
                Range: nonnegative;
                Definition: 1;
            }
            Parameter PI_Class {
                IndexDomain: i;
            }
            Parameter PI_Point {
                IndexDomain: (i,d);
                Text: "A vector in \\Re^d";
                Range: free;
            }
            ElementParameter PE_Class {
                IndexDomain: i;
                Range: SI_Classes;
            }
        }
    }
    Section REFINED_DATA {
        DeclarationSection Refined_Set_Declarations {
            Set SD_Neighbors_and_Non {
                SubsetOf: (SI_Points,SI_Points);
                Definition: {
                    
                    { (i,j) | i <> j }
                }
            }
            Set SD_Ri {
                SubsetOf: (SI_Points,SI_Points_Outliers_Ri);
                Definition: {
                    
                    { (i,j) | i <> j }
                }
            }
            Set SD_Ri_1 {
                SubsetOf: (SI_Points,SI_Points);
                Definition: {
                    
                    SD_Neighbors-SD_Ri
                }
            }
            Set SD_Ri_2 {
                SubsetOf: (SI_Points,SI_Points);
                Definition: {
                    
                    SD_Non_Neighbors-SD_Ri
                }
            }
            Set SD_Neighbors {
                SubsetOf: (SI_Points,SI_Points);
                Definition: {
                    
                    { (i,j) | i <> j and PE_Class(i) = PE_Class(j) }
                }
            }
            Set SD_Non_Neighbors {
                SubsetOf: (SI_Points,SI_Points);
                Definition: {
                    
                    { (i,j) | PE_Class(i) <> PE_Class(j) }
                }
            }
        }
        DeclarationSection Refined_Parameter_Declarations {
            Parameter PD_Delta {
                IndexDomain: (i,j,d);
                Text: "Coordinate distance between two points";
                Range: free;
                Definition: {
                    PI_Point(i,d)-PI_Point(j,d)
                    !abs(PI_Point(i,d)-PI_Point(j,d))
                }
            }
            Parameter PD_L2_Norm {
                IndexDomain: i;
                Range: nonnegative;
                Definition: {
                    
                    sqrt( sum[ d , PI_Point(i, d)**2 ] )
                }
            }
            Parameter PD_L2_Distance {
                IndexDomain: (i,j);
                Text: "Euclidean distance between point \'i\' and point \'j\'";
                Range: nonnegative;
                Definition: {
                    
                    sqrt( sum[ d , (PI_Point(i, d)-PI_Point(j, d))^2 ] )
                }
            }
            Parameter PD_L2_Distance_To_Closest_Neighbor {
                IndexDomain: i;
                Range: nonnegative;
                Definition: {
                    
                    min[ j | (i,j) in SD_Neighbors , PD_L2_Distance(i, j) ]
                }
            }
            Parameter PD_L2_Distance_To_Closest_Non_Neighbor {
                IndexDomain: i;
                Range: nonnegative;
                Definition: {
                    
                    min[ k | (i,k) in SD_Non_Neighbors , PD_L2_Distance(i, k) ]
                }
            }
            Parameter PD_L2_Separation {
                IndexDomain: i;
                Text: "Separation (L2 distance) between closest non-neighbor and closest neighbor (may be negative)";
                Range: free;
                Definition: PD_L2_Distance_To_Closest_Non_Neighbor(i) - PD_L2_Distance_To_Closest_Neighbor(i);
            }
            Parameter PD_Min_Coord {
                Range: free;
                Definition: {
                    
                    min[ (i,d) , PI_Point(i, d) ]
                }
            }
            Parameter PD_Max_Coord {
                Range: free;
                Definition: {
                    
                    max[ (i,d) , PI_Point(i, d) ]
                }
            }
        }
    }
    Section MATH_PROGRAMS {
        Section MILP_Section6_3 {
            DeclarationSection MILP6_3_Problem {
                Variable VC_MILP6_3_OBJ {
                    Range: free;
                    Definition: sum[i_a, VC_Lambda_1(i_a)-PD_Rho_1 * VC_Z_1(i_a)];
                }
                MathematicalProgram MILP6_3_Problem_solve {
                    Objective: VC_MILP6_3_OBJ;
                    Direction: maximize;
                    Constraints: SD_MILP6_3_Problem_Constraints;
                    Variables: SD_MILP6_3_Problem_Variables;
                    Type: Automatic;
                }
                Set SD_MILP6_3_Problem_Variables {
                    SubsetOf: AllVariables;
                    Definition: AllVariables * ( MILP_Section6_3);
                }
                Set SD_MILP6_3_Problem_Constraints {
                    SubsetOf: AllConstraints;
                    Definition: AllConstraints * (MILP_Section6_3);
                }
            }
            DeclarationSection MILP6_3_Constraints {
                Constraint CL_VC_Y_1 {
                    IndexDomain: i_a;
                    Definition: 1 = sum[ j_a | (i_a,j_a) in SD_Neighbors , VC_Y_1(i_a,j_a) ];
                }
                Constraint CL_lambda_condition_1 {
                    IndexDomain: i_a;
                    Definition: {
                        VC_Lambda_1(i_a) <= 1 - VC_Z_1(i_a);
                    }
                }
                Constraint CL_MILP6_3_Max_Min_Dist_To_Nearest_Non_Neighbor {
                    IndexDomain: (i_a,k_a) | (i_a,k_a) in SD_Non_Neighbors;
                    Definition: {
                        
                        sum[ j_a | (i_a,j_a) in SD_Neighbors , PD_Distance(i_a,j_a)*VC_Y_1(i_a,j_a)  ] + VC_Lambda(i_a) <= PD_Distance(i_a,k_a) + PI_MAX_DISTANCE * [VC_Z_1(i_a)+VC_Z_1(k_a)];
                    }
                }
                Constraint CL_Y_condition {
                    IndexDomain: (i_a,j_a) | (i_a,j_a) in SD_Neighbors;
                    Definition: {
                        
                        VC_Y_1(i_a,j_a) + VC_Z_1(j_a) <=1 ;
                    }
                }
                Constraint CL_Z_condition {
                    IndexDomain: i_a_n;
                    Definition: {
                        
                        VC_Z_1(i_a_n) =0 ;
                    }
                }
            }
            DeclarationSection MILP6_3_Variables {
                Variable VC_Lambda_1 {
                    IndexDomain: i_a;
                    Range: nonnegative;
                }
                Variable VC_Y_1 {
                    IndexDomain: (i_a,j_a) | (i_a,j_a) in SD_Neighbors;
                    Text: "Weight of dij";
                    Range: binary;
                }
                Variable VC_Z_1 {
                    IndexDomain: i_a;
                    Text: "Define if point i is an Outlier";
                    Range: binary;
                }
            }
            DeclarationSection MILP6_3_Parameters {
                Parameter PD_Q_Coeff {
                    IndexDomain: (d1,d2);
                }
                Parameter PD_Distance {
                    IndexDomain: (i_a,j_a) | i_a <> j_a;
                    Range: [0, PI_MAX_DISTANCE];
                    Definition: {
                        sum[ d , PD_Delta(i_a,j_a,d)^2 * VC_Q_Coeff(d,d) ]
                        +
                        2*sum[ (d1,d2) | ord(d1) < ord(d2) , PD_Delta(i_a,j_a,d1) * PD_Delta(i_a,j_a,d2) * PD_Q_Coeff(d1,d2) ]
                    }
                }
                Parameter PD_Rho_1 {
                    Text: "Penalty Parameter";
                    Default: 0;
                    Definition: 2;
                }
            }
        }
        Section COMMON {
            DeclarationSection Common_Variables {
                Variable VC_Lambda_Robust {
                    Range: free;
                }
                Variable VC_Lambda {
                    IndexDomain: i_a;
                    Range: nonnegative;
                }
                Variable VC_Distance {
                    IndexDomain: (i_a,j_a) | i_a <> j_a;
                    Text: "Distance between point \'i_a\' and point \'j_a\'";
                    Range: [0, PI_MAX_DISTANCE];
                    Definition: {
                        sum[ d , PD_Delta(i_a,j_a,d)^2 * VC_Q_Coeff(d,d) ]
                        +
                        2*sum[ (d1,d2) | ord(d1) < ord(d2) , PD_Delta(i_a,j_a,d1) * PD_Delta(i_a,j_a,d2) * VC_Q_Coeff(d1,d2) ]
                        
                        !range [0, PI_MAX_DISTANCE]
                    }
                    Comment: "[0, PI_MAX_DISTANCE]";
                }
                Variable VC_Min_Dist {
                    IndexDomain: i_a;
                    Range: nonnegative;
                }
                Variable VC_Q_Coeff {
                    IndexDomain: (d1,d2) | ord(d1) <= ord(d2);
                    Range: free;
                    Definition: {
                        !0$(ord(d1) < ord(d2))
                        !if (ord(d1) < ord(d2)) then VC_Q_Coeff(d1,d2)=0 endif;
                        ! index domain | ord(d1) <= ord(d2)
                    }
                }
                Variable VC_Separation {
                    IndexDomain: i_a;
                    Text: "Separation between the nearest neighbor of point \'i_a\' and its nearest non-neighbor";
                    Range: nonnegative;
                }
                Variable VC_Violation {
                    IndexDomain: i_a;
                    Range: nonnegative;
                }
            }
            DeclarationSection Common_Constraints {
                Constraint CL_Q_Coeff {
                    IndexDomain: (d1,d2);
                    Definition: {
                        !if (ord(d1) < ord(d2)) then VC_Q_Coeff(d1,d2)=0 else 1=1 endif;
                        1=1;
                    }
                }
            }
        }
        Section BIGM_MILP {
            DeclarationSection BIGM_Parameters;
            DeclarationSection BIGM_Variables {
                Variable VB_Is_Nearest_Neighbor_Pair {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Range: binary;
                }
                Variable VC_Bilinear {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Range: [0, PI_MAX_DISTANCE];
                }
                Variable VB_Is_Outlier {
                    IndexDomain: i;
                    Range: binary;
                }
            }
            DeclarationSection BIGM_Constraints {
                Constraint CE_Min_Dist_Definition {
                    IndexDomain: (i,k);
                    Definition: {
                        
                        sum[ j | (i,j) in SD_Neighbors , VC_Bilinear(i, j) ]
                        +
                        VC_Min_Dist(i)
                        =
                        VC_Distance(i, k)
                        +
                        VB_Is_Outlier(i)
                    }
                }
                Constraint CL_McCormick1 {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Definition: {
                        
                        VC_Bilinear(i, j) <= VC_Distance(i, j)
                    }
                }
                Constraint CL_McCormick2 {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Definition: {
                        
                        VC_Bilinear(i, j) <= VB_Is_Nearest_Neighbor_Pair(i, j)
                    }
                }
                Constraint CG_McCormick3 {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Definition: {
                        
                        VC_Bilinear(i, j) >=  VC_Distance(i, j) + VB_Is_Nearest_Neighbor_Pair(i, j) - 1
                    }
                }
                Constraint CE_Select_At_Most_One_Neighbor {
                    IndexDomain: i;
                    Definition: {
                        
                        sum[ j | (i,j) in SD_Neighbors , VB_Is_Nearest_Neighbor_Pair(i, j) ] = 1 - VB_Is_Outlier(i)
                    }
                }
            }
            DeclarationSection BIGM_MP;
        }
        Section MILP_Section4 {
            DeclarationSection MILP_Problem {
                Variable VC_MILP_OBJ {
                    Range: free;
                    Definition: sum[i, VC_Lambda(i)-PD_Rho * VC_Z(i)];
                }
                MathematicalProgram MILP_Problem_solve {
                    Objective: VC_MILP_OBJ;
                    Direction: maximize;
                    Constraints: SD_MILP_Problem_Constraints;
                    Variables: SD_MILP_Problem_Variables;
                    Type: Automatic;
                }
                Set SD_MILP_Problem_Variables {
                    SubsetOf: AllVariables;
                    Definition: AllVariables * (COMMON + MILP_Section4);
                }
                Set SD_MILP_Problem_Constraints {
                    SubsetOf: AllConstraints;
                    Definition: AllConstraints * (COMMON + MILP_Section4);
                }
            }
            DeclarationSection MILP_Constraints {
                Constraint CL_VC_Y {
                    IndexDomain: i;
                    Definition: 1 = sum[ j | (i,j) in SD_Neighbors , VC_Y(i,j) ];
                }
                Constraint CL_lambda_condition {
                    IndexDomain: i;
                    Definition: {
                        VC_Lambda(i) <= 1 - VC_Z(i);
                    }
                }
                Constraint CL_MILP_Max_Min_Dist_To_Nearest_Non_Neighbor {
                    IndexDomain: (i,k) | (i,k) in SD_Non_Neighbors;
                    Definition: {
                        
                        sum[ j | (i,j) in SD_Neighbors , VC_W(i,j) ] + VC_Lambda(i) <= VC_Distance(i,k) + PI_MAX_DISTANCE * VC_Z(i);
                    }
                }
                Constraint CL_McCormick_envolopes_1 {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Definition: {
                        VC_W(i,j) <= VC_Distance(i,j);
                    }
                }
                Constraint CL_McCormick_envolopes_2 {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Definition: {
                        VC_W(i,j) <= VC_Y(i,j);
                    }
                }
                Constraint CL_McCormick_envolopes_3 {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Definition: {
                        VC_W(i,j) >= VC_Distance(i,j) + VC_Y(i,j) - 1;
                    }
                }
            }
            DeclarationSection MILP_Variables {
                Variable VC_Y {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Text: "Weight of dij";
                    Range: binary;
                }
                Variable VC_W {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Text: "Weighted dij";
                    Range: nonnegative;
                    Default: 0;
                }
                Variable VC_Z {
                    IndexDomain: i;
                    Text: "Define if point i is an Outlier";
                    Range: binary;
                }
            }
            DeclarationSection MILP_Parameters {
                Parameter PD_Rho {
                    Text: "Penalty Parameter";
                    Default: 0;
                    Definition: 0.1;
                }
            }
        }
        Section MILP_Section4_Robust {
            DeclarationSection MILP_Robust_Problem {
                Variable VC_MILP_Robust_OBJ {
                    Range: free;
                    Definition: VC_Lambda_Robust-PD_Robust_Rho *sum[i , VC_Z(i)];
                }
                MathematicalProgram MILP_Robust_Problem_solve {
                    Objective: VC_MILP_Robust_OBJ;
                    Direction: maximize;
                    Constraints: SD_MILP_Robust_Problem_Constraints;
                    Variables: SD_MILP_Robust_Problem_Variables;
                    Type: Automatic;
                }
                Set SD_MILP_Robust_Problem_Variables {
                    SubsetOf: AllVariables;
                    Definition: AllVariables * (COMMON + MILP_Section4_Robust + MILP_Section4);
                }
                Set SD_MILP_Robust_Problem_Constraints {
                    SubsetOf: AllConstraints;
                    Definition: AllConstraints * (COMMON + MILP_Section4_Robust);
                }
            }
            DeclarationSection MILP_Robust_Constraints {
                Constraint CL_Robust_VC_Y {
                    IndexDomain: i;
                    Definition: 1 = sum[ j | (i,j) in SD_Neighbors , VC_Y(i,j) ];
                }
                Constraint CL_Robust_lambda_condition {
                    IndexDomain: i;
                    Definition: {
                        VC_Lambda(i) <= 1 - VC_Z(i);
                    }
                }
                Constraint CL_MILP_Robust_Max_Min_Dist_To_Nearest_Non_Neighbor {
                    IndexDomain: (i,k) | (i,k) in SD_Non_Neighbors;
                    Definition: {
                        
                        sum[ j | (i,j) in SD_Neighbors , VC_W(i,j) ] + VC_Lambda_Robust <= VC_Distance(i,k) + PI_MAX_DISTANCE * VC_Z(i);
                    }
                }
                Constraint CL_Robust_McCormick_envolopes_1 {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Definition: {
                        VC_W(i,j) <= VC_Distance(i,j);
                    }
                }
                Constraint CL_Robust_McCormick_envolopes_2 {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Definition: {
                        VC_W(i,j) <= VC_Y(i,j);
                    }
                }
                Constraint CL_Robust_McCormick_envolopes_3 {
                    IndexDomain: (i,j) | (i,j) in SD_Neighbors;
                    Definition: {
                        VC_W(i,j) >= VC_Distance(i,j) + VC_Y(i,j) - 1;
                    }
                }
            }
            DeclarationSection MILP_Robust_Variables;
            DeclarationSection MILP_Robust_Parameters {
                Parameter PD_Robust_Rho {
                    Text: "Penalty Parameter";
                    Default: 0;
                    Definition: 0.1;
                }
            }
        }
        Section FEASIBILITY_LP {
            DeclarationSection Feasibility_LP_Variables {
                Variable VC_Objval_Max_Dist_To_Nearest_Non_Neighbor {
                    Range: free;
                    Definition: {
                        
                        sum[ i_a, VC_Min_Dist(i_a) ]
                    }
                }
            }
            DeclarationSection Feasiblity_LP_Constraints {
                Constraint CL_Min_Dist_LEQ_All_Neighbors {
                    IndexDomain: (i_a,j_a) | (i_a,j_a) in SD_Neighbors;
                    Definition: {
                        
                        VC_Min_Dist(i_a) <= VC_Distance(i_a,j_a)
                    }
                }
                Constraint CL_Max_Min_Dist_To_Nearest_Non_Neighbor {
                    IndexDomain: (i_a,k_a) | (i_a,k_a) in SD_Non_Neighbors;
                    Definition: {
                        
                        VC_Min_Dist(i_a) + PI_EPSILON <= VC_Distance(i_a,k_a)
                    }
                }
            }
            DeclarationSection Feasibility_LP_MP {
                MathematicalProgram MP_Feasibility_LP {
                    Objective: VC_Objval_Max_Dist_To_Nearest_Non_Neighbor;
                    Direction: maximize;
                    Constraints: SD_Feasibility_LP_Constraints;
                    Variables: SD_Feasibility_LP_Variables;
                    Type: LP;
                }
                Set SD_Feasibility_LP_Variables {
                    SubsetOf: AllVariables;
                    Definition: AllVariables * (COMMON + FEASIBILITY_LP);
                }
                Set SD_Feasibility_LP_Constraints {
                    SubsetOf: AllConstraints;
                    Definition: AllConstraints * (COMMON + FEASIBILITY_LP);
                }
            }
        }
        Section MAX_EPSILON_LP {
            DeclarationSection Maximum_Epsilon_LP_MP {
                Variable VC_Epsilon {
                    Range: free;
                }
                Constraint CL_Max_Epsilon_Dist_To_Nearest_Non_Neighbor {
                    IndexDomain: (i_a,k_a) | (i_a,k_a) in SD_Non_Neighbors;
                    Definition: {
                        
                        VC_Epsilon <= VC_Distance(i_a,k_a)
                    }
                }
                MathematicalProgram MP_Max_Epsilon_LP {
                    Objective: VC_Epsilon;
                    Direction: maximize;
                    Constraints: SD_Max_Epsilon_LP_Constraints;
                    Variables: SD_Max_Epsilon_LP_Variables;
                    Type: LP;
                }
                Set SD_Max_Epsilon_LP_Variables {
                    SubsetOf: AllVariables;
                    Definition: AllVariables * (COMMON + MAX_EPSILON_LP);
                }
                Set SD_Max_Epsilon_LP_Constraints {
                    SubsetOf: AllConstraints;
                    Definition: AllConstraints * (COMMON + MAX_EPSILON_LP);
                }
            }
        }
    }
    Section HEURISTICS {
        Section Temp_Procedure {
            Procedure Procedure_1 {
                Body: {
                    PO_R_store_(i_out_1,'1'):=PO_R_store_(i_out_1,'1')-PO_R_store_(i_out_1,'1');
                }
            }
            Procedure Proc_Read_Instance_From_Text_File_copy {
                Body: {
                    if (FileSelect(filename : PSI_TEXTFILE_NAME, directory : "data/", extension : "*.txt", title : "Load text input file")) then
                    
                    	read from file PSI_TEXTFILE_NAME;
                    
                    endif;
                }
            }
            Procedure Copy_Proc_Iterative_LP_Loop {
                Body: {
                    !!! ASSIGNMENT
                    SI_Points:= SI_Points-SD_LP_Outlier_Points;
                    Solve_Max_Epsilon_LP;
                    PO_Max_Epsilon := VC_Epsilon;
                    
                    for i_Ri do
                    
                    	PI_EPSILON := ( ord( i_Ri ) / PI_Num_Epsilons ) * PO_Max_Epsilon;	
                    	PI_Store_EPSILON(i_Ri):= PI_EPSILON;
                    	Solve MP_Feasibility_LP;
                    	PO_Store_Q_coeff(i_Ri,d1,d2):=PO_Q_Coeff(d1,d2);
                    	PO_Store_Num_outlier(i_Ri):=0;
                    	for i do
                    		if (PO_Min_Dist_Achieved(i) = 0) then
                    			PO_Store_Num_outlier(i_Ri):= PO_Store_Num_outlier(i_Ri)+1;
                    		endif
                    	endfor
                    	!!! TODO: 
                    	!!! Store the number of outliers. Hint: Create a new parameter that uses PO_Is_LP_Outlier
                    	!!! Store the distance metric
                    
                    endfor;
                    
                    !!! TODO: Create a 2D "epsilon vs. number of outliers" 
                    !!! That is, plot with epsilon on the x axis and "number of outliers" on the y axis.  
                    !!! What do you expect this plot to look like?
                }
            }
            Procedure Proc_Iterative_LP_Solve_Remove_resolve_1 {
                Body: {
                    
                    SI_points_Active := SI_points;
                    Solve_Max_Epsilon_LP;
                    PO_Max_Epsilon := VC_Epsilon;
                    	PI_EPSILON := PO_Max_Epsilon;	
                    	PI_Store_EPSILON(1):= PI_EPSILON;
                    
                    
                    	!Solve MP_Feasibility_LP;
                    	PO_Store_Q_coeff(1,d1,d2):=PO_Q_Coeff(d1,d2);
                }
            }
            Procedure Proc_Iterative_LP_Solve_Remove_resolve_2 {
                Body: {
                    
                    
                    	SI_Points_Outliers := SI_Points_Outliers + SD_LP_Outlier_Points;
                    	SI_points_Active:= SI_Points_Active-SD_LP_Outlier_Points;
                    	PI_EPSILON := PI_Epsilon_div_MAXEpsilon * PO_Max_Epsilon;
                    	Solve MP_Feasibility_LP;
                    	!Solve_Max_Epsilon_LP;
                    	PO_Store_Q_coeff(2,d1,d2):=PO_Q_Coeff(d1,d2);
                    
                    	!!! TODO: 
                    	!!! Store the number of outliers. Hint: Create a new parameter that uses PO_Is_LP_Outlier
                    	!!! Store the distance metric
                }
            }
            Procedure Proc_Iterative_LP_Solve_Remove_resolve_3_1 {
                Body: {
                    PI_Countnum_o:=0;
                    for i_out do
                    PI_Countnum_o:=PI_Countnum_o+1;
                    endfor;
                    for i_out do
                    	SI_Points_Active := SI_Points_Active + i_out;
                    	if PO_Is_LP_Outlier(i_out) = 0 then
                    		SI_Points_Outliers := SI_Points_Outliers - i_out;
                    		SI_Points_Active := SI_Points - SI_Points_Outliers;
                    	else SI_Points_Active := SI_Points_Active - i_out;
                    	endif;
                    	solve MP_Feasibility_LP;
                    endfor;
                }
            }
            Procedure Proc_Iterative_LP_Solve_Remove_resolve_3 {
                Body: {
                    PI_Countnum_o:=0;
                    for i_out do
                    PI_Countnum_o:=PI_Countnum_o+1;
                    endfor;
                    for i_out do
                    	SI_Points_Active := SI_Points_Active + i_out;
                    	if PO_Is_LP_Outlier(i_out) = 0 then
                    		SI_Points_Outliers := SI_Points_Outliers - i_out;
                    		SI_Points_Active := SI_Points - SI_Points_Outliers;
                    	else SI_Points_Active := SI_Points_Active - i_out;
                    	endif;
                    endfor;
                    	solve MP_Feasibility_LP;
                }
            }
            Procedure Proc_Iterative_LP_Solve_Remove_resolve_Ri_1 {
                Body: {
                    SI_Points_Outliers_1:=SI_Points-SI_Points_Active;
                    PI_Countnum_o:=0;
                    for i_out_1 do
                    PI_Countnum_o:=PI_Countnum_o+1;
                    endfor;
                    for i_num_o do	
                    	for i_out_1 do
                    		PO_R_store_(i_out_1,i_num_o):=PO_R(i_out_1)
                    	endfor;
                    	SI_Points_Active := SI_Points_Active + argmax(i_out_1, PO_R(i_out_1)) ;
                    	SI_Points_Outliers_2 := argmax(i_out_1, PO_R(i_out_1));
                    	for i_out_2 do
                    		if PO_Is_LP_Outlier(i_out_2) = 0 then
                    			SI_Points_Outliers_1 := SI_Points_Outliers_1 - i_out_2;
                    		else 
                    			SI_Points_Active := SI_Points_Active - i_out_2;
                    			SI_Points_Outliers_1 := SI_Points_Outliers_1 - i_out_2;
                    		endif;
                    	endfor;
                    	solve MP_Feasibility_LP;
                    endfor;
                }
            }
            Procedure Proc_Iterative_LP_Solve_Remove_resolve_Ri {
                Body: {
                    SI_Points_Outliers_1:=SI_Points-SI_Points_Active;
                    SI_Points_Outliers_Ri:=SI_Points_Outliers_1;
                    PI_Countnum_o:=0;
                    for i_out_1 do
                    PI_Countnum_o:=PI_Countnum_o+1;
                    endfor;
                    PO_R_store_(i_out_1,'1'):=PO_R_store_(i_out_1,'1')-PO_R_store_(i_out_1,'1');
                    for i_out_1 do
                    		PO_R_store_(i_out_1,'1'):=PO_R(i_out_1);
                    endfor;
                    for i_num_o do	
                    
                    	SI_Points_Active := SI_Points_Active + argmax(i_out_1, PO_R(i_out_1)) ;
                    	SI_Points_Outliers_2 := argmax(i_out_1, PO_R(i_out_1));
                    	for i_out_2 do
                    		if PO_Is_LP_Outlier(i_out_2) = 0 then
                    			SI_Points_Outliers_1 := SI_Points_Outliers_1 - i_out_2;
                    		else 
                    			SI_Points_Active := SI_Points_Active - i_out_2;
                    			SI_Points_Outliers_1 := SI_Points_Outliers_1 - i_out_2;
                    		endif;
                    	endfor;
                    endfor;
                    SI_Points_Outliers_1:=SI_Points-SI_Points_Active;
                    SI_Points_Outliers:=SI_Points_Outliers_1;
                    solve MP_Feasibility_LP;
                }
            }
            Procedure Proc_delete_outliers {
                Body: {
                    SI_points_Active:= SI_points - SI_Points_Outliers;
                }
            }
            Procedure Proc_delete_outliers_1 {
                Body: {
                    SI_points_Active:= SI_points - SI_Points_Outliers_1;
                }
            }
            Procedure Proc_put_back_outliers {
                Body: {
                    
                    SI_Points_Active:= SI_Points;
                }
            }
        }
        Procedure Proc_Comparations_with_methods {
            Body: {
                Proc_Iterative_LP_Solve_Remove_resolve_1;
                Proc_Iterative_LP_Solve_Remove_resolve_2;
                PO_Num_outliers('1'):=0;
                for i_out do
                	PO_Num_outliers('1'):=PO_Num_outliers('1')+1;
                endfor;
                
                
                Proc_Iterative_LP_Solve_Remove_resolve_1;
                Proc_Iterative_LP_Solve_Remove_resolve_2;
                for i_num_iterations do
                	Proc_Iterative_LP_Solve_Remove_resolve_3;
                endfor;
                PO_Num_outliers('2'):=0;
                for i_out do
                	PO_Num_outliers('2'):=PO_Num_outliers('2')+1;
                endfor;
                
                
                Proc_Iterative_LP_Solve_Remove_resolve_1;
                Proc_Iterative_LP_Solve_Remove_resolve_2;
                for i_num_iterations do
                	Proc_Iterative_LP_Solve_Remove_resolve_Ri;
                endfor;
                PO_Num_outliers('3'):=0;
                for i_out_1 do
                	PO_Num_outliers('3'):=PO_Num_outliers('3')+1;
                endfor;
                
                Proc_Iterative_LP_Solve_Remove_resolve_1;
                Proc_Iterative_LP_Solve_Remove_resolve_2;
                Solve_MILP6_3_Problem;
                PO_Num_outliers('4'):=0;
                for i_out do
                	PO_Num_outliers('4'):=PO_Num_outliers('4')+1;
                endfor;
            }
        }
        Procedure Solve_MILP6_3_Problem {
            Body: {
                PD_Q_Coeff(d1,d2):=VC_Q_Coeff(d1,d2);
                SI_Points_Active:=SI_Points;
                SI_Points_Active_NonOutliers:=SI_Points_Active-SI_Points_Outliers;
                solve MILP6_3_Problem_solve;
                
                SI_Points_Outliers:=SI_Points_Outliers-SI_Points_Outliers;
                for i_a do
                	if VC_Z_1(i_a)=1 
                		then SI_Points_Outliers:=SI_Points_Outliers+i_a;
                	endif
                endfor;
                SI_Points_Active:=SI_Points - SI_Points_Outliers;
            }
        }
        Procedure Solve_MILP_Robust_Problem {
            Body: {
                solve MILP_Robust_Problem_solve where
                 time_limit = 10;
            }
        }
        Procedure Solve_MILP_Problem {
            Body: {
                solve MILP_Problem_solve where
                 time_limit = 10;
            }
        }
        Procedure Solve_Max_Epsilon_LP {
            Body: {
                
                Solve MP_Max_Epsilon_LP;
            }
        }
        Procedure Solve_Feasibility_LP {
            Body: {
                !PI_EPSILON := 0.02;
                !VC_Min_Dist(i).level := 0;
                !VC_Min_Dist(i).nonvar := 1;
                !VC_Q_Coeff(d,d) := 1;
                !VC_Q_Coeff(d,d).nonvar := 1;
                
                PI_EPSILON:=0.000001;
                
                Solve MP_Feasibility_LP;
                
                
                VC_Min_Dist(i).nonvar := 0;
                VC_Q_Coeff(d,d).nonvar := 0;
            }
        }
        Procedure Proc_Iterative_LP_Loop {
            Body: {
                !!! ASSIGNMENT
                SI_Points_Active:=SI_Points;
                Solve_Max_Epsilon_LP;
                PO_Max_Epsilon := VC_Epsilon;
                PI_Num_Epsilons_1:=PI_Num_Epsilons +1;
                for i_Ri do
                
                	PI_EPSILON := (( ord( i_Ri )-1 )/ PI_Num_Epsilons ) * PO_Max_Epsilon;	
                	PI_Store_EPSILON(i_Ri):= PI_EPSILON;
                	Solve MP_Feasibility_LP;
                	PO_Store_Q_coeff(i_Ri,d1,d2):=PO_Q_Coeff(d1,d2);
                	PO_Store_Num_outlier(i_Ri):=0;
                	for i do
                		if (PO_Min_Dist_Achieved(i) = 0) then
                			PO_Store_Num_outlier(i_Ri):= PO_Store_Num_outlier(i_Ri)+1;
                		endif
                	endfor
                	!!! TODO: 
                	!!! Store the number of outliers. Hint: Create a new parameter that uses PO_Is_LP_Outlier
                	!!! Store the distance metric
                
                endfor;
                
                !!! TODO: Create a 2D "epsilon vs. number of outliers" 
                !!! That is, plot with epsilon on the x axis and "number of outliers" on the y axis.  
                !!! What do you expect this plot to look like?
            }
        }
        Procedure Proc_DJP_Loop {
            Body: {
                Solve_Max_Epsilon_LP;
                PI_EPSILON := VC_Epsilon/2;
                Solve MP_Feasibility_LP;
            }
        }
        Set SD_Epsilon_Indices {
            SubsetOf: Integers;
            Index: i_Ri;
            Definition: {
                {1 .. PI_Num_Epsilons+1}
            }
        }
        Set SD_Outliers_Num_Indices {
            SubsetOf: Integers;
            Index: i_Outliers_Num;
            Definition: {
                {1 .. PI_Outliers_Num}
            }
        }
        Set SD_Iterations_Num_Indices {
            SubsetOf: Integers;
            Index: i_num_iterations;
            Definition: {
                {1 .. PI_Iterations_Num}
            }
        }
        Set SD_Count_Indices {
            SubsetOf: Integers;
            Index: i_num_o;
            Definition: {
                {1 .. PI_Countnum_o}
            }
        }
        Set SD_Methods_Indices {
            SubsetOf: Integers;
            Index: i_num_methods;
            Definition: {
                {1 .. PI_methods_count}
            }
        }
        Parameter PI_Num_Epsilons {
            Range: integer;
            InitialData: 5;
        }
        Parameter PI_Num_Epsilons_1 {
            Range: integer;
        }
        Parameter PI_Epsilon_div_MAXEpsilon {
            InitialData: 0.5;
        }
        DeclarationSection Output_Declarations {
            Parameter PI_Iterations_Num {
                InitialData: 1;
            }
            Parameter PI_Outliers_Num {
                Range: integer;
            }
            Parameter PI_methods_count {
                Range: integer;
                Definition: 4;
            }
            Parameter PO_Num_outliers {
                IndexDomain: i_num_methods;
            }
            Parameter PI_Countnum_o;
            Parameter PO_R_store_ {
                IndexDomain: (i_out,i_num_o);
            }
            Parameter temp;
            Parameter PO_R {
                IndexDomain: i_out;
                Range: nonnegative;
                Definition: {
                    !min[ j | (i,j) in SD_Non_Neighbors , VC_Distance(i, j) ] / min[ j | (i,j) in SD_Neighbors , VC_Distance(i, j) ] 
                     min[ j_a | (i_out,j_a) in SD_Ri_1  , sum[ d , PD_Delta(i_out,j_a,d)^2 * VC_Q_Coeff(d,d) ] + 2*sum[ (d1,d2) | ord(d1) < ord(d2) , PD_Delta(i_out,j_a,d1) * PD_Delta(i_out,j_a,d2) * VC_Q_Coeff(d1,d2) ] ]
                     /
                     min[ j_a | (i_out,j_a) in  SD_Ri_2 , sum[ d , PD_Delta(i_out,j_a,d)^2 * VC_Q_Coeff(d,d) ] + 2*sum[ (d1,d2) | ord(d1) < ord(d2) , PD_Delta(i_out,j_a,d1) * PD_Delta(i_out,j_a,d2) * VC_Q_Coeff(d1,d2) ] ]
                }
            }
            Parameter PO_Store_Q_coeff {
                IndexDomain: (i_Ri,d1,d2);
            }
            Parameter PO_Store_Num_outlier {
                IndexDomain: i_Ri;
            }
            Parameter PI_TOLERANCE {
                Range: nonnegative;
                Definition: 1e-5;
            }
            Parameter PO_Max_Epsilon;
            Parameter PO_LP_Separation {
                IndexDomain: i_a;
                Range: free;
                Definition: {
                    
                    !VC_Min_Dist(i) - min[ j | (i,j) in SD_Neighbors , VC_Distance(i, j) ]
                    min[ j_a | (i_a,j_a) in  SD_Neighbors_and_Non, sum[ d , PD_Delta(i_a,j_a,d)^2 * PO_Q_Coeff(d,d) ] + 2*sum[ (d1,d2) | ord(d1) < ord(d2) , PD_Delta(i_a,j_a,d1) * PD_Delta(i_a,j_a,d2) * PO_Q_Coeff(d1,d2) ] ]- min[ j_a | (i_a,j_a) in SD_Neighbors , sum[ d , PD_Delta(i_a,j_a,d)^2 * PO_Q_Coeff(d,d) ] + 2*sum[ (d1,d2) | ord(d1) < ord(d2) , PD_Delta(i_a,j_a,d1) * PD_Delta(i_a,j_a,d2) * PO_Q_Coeff(d1,d2) ] ]
                }
                Comment: "Ideally, this parameter should be 0. If this quantity is negative, the point i is an outlier.";
            }
            Parameter PO_Min_Dist_Achieved {
                IndexDomain: i_a;
                Range: binary;
                Definition: {
                    
                    if ( PO_LP_Separation(i_a) + PI_TOLERANCE >= 0 ) then
                    	1
                    else
                    	0
                    endif;
                }
            }
            Parameter PO_Is_LP_Outlier {
                IndexDomain: i_a;
                Range: binary;
                Definition: {
                    
                    1-PO_Min_Dist_Achieved(i_a)
                }
            }
            Parameter PO_Q_Coeff {
                IndexDomain: (d1,d2);
                Definition: {
                    if ( ord(d1) <= ord(d2) ) then
                    	VC_Q_Coeff(d1, d2)
                    else
                    	VC_Q_Coeff(d2, d1)
                    endif;
                }
            }
        }
    }
    Section INSTANCE_GENERATOR {
        Procedure Proc_Save_Instance {
            Body: {
                Instance_File.pagewidth := PI_Pagewidth;
                
                !PS_Current_Date_And_Time := CurrentToString("%m%d%H%M");
                PS_Instance_Name_Only := "Clustering_instance" + "_P" + PI_Num_Points + "_C" + PI_Num_Classes + "_D" + Card(SI_Dimensions) + ".txt";
                PS_Instance_File := PS_Instance_Directory + PS_Instance_Name_Only;
                
                put Instance_File;
                
                display SI_Points, SI_Classes, SI_Dimensions;
                display PE_Class;
                display PI_Point;
                
                putclose Instance_File;
            }
        }
        DeclarationSection Save_Instance_Declaration {
            File Instance_File {
                Name: PS_Instance_File;
                Device: Disk;
                Mode: replace;
            }
            StringParameter PS_Instance_File;
            StringParameter PS_Instance_Directory {
                Definition: "data/text_instances/";
            }
            StringParameter PS_Instance_Name_Only;
            Parameter PI_Pagewidth {
                Definition: 70;
            }
        }
        Parameter PI_Outlier_Probability {
            Range: [0, 1];
            InitialData: 0;
        }
        Parameter PI_Noise {
            Range: [0, 1];
            InitialData: 0;
        }
        DeclarationSection NOTE {
            Comment: {
                "Consider adding a function to generate more points to an already generated instance.
                
                What are the steps one would take?
                (1) Attempt to use Euclidean distance
                (2) If Euclidean distance is not suitable (leads to outliers), modify the distance metric
                (3) Using a PWL function with a constant penalty for outliers,
                vary the penalty constant from small to large to see how the distance metrics perform
                User inputs the range of the penalty parameter, e.g.,
                -1 to -10 by 1"
            }
        }
        Section GAUSSIAN_2D {
            Procedure delete_newpoints {
                Body: {
                    SI_Points := SI_Points - SI_New_Points;
                }
            }
            Parameter P_sigma_Gaussian;
            Parameter P_miu_Gaussian;
            Parameter P_Radius_Gaussian;
            Parameter PI_Num_Points_Annulus2d;
            Parameter PI_Num_Classes_Annulus2d {
                Range: integer;
            }
            Parameter P_Angle;
            Parameter P_Radius {
                Range: nonnegative;
            }
            Parameter P_Radius_Noise {
                Range: nonnegative;
            }
            Procedure Proc_Generate_Random_Instance_Gaussian_2D {
                Body: {
                    !PI_NUM_POINTS := 200;
                    !PI_Num_Classes_Annulus2d := 4;
                    SI_Classes := ElementRange(
                    	From    :  1,
                    	To      :  PI_Num_Classes,
                    	Incr    :  1,
                    	Prefix  :  'c',
                    	Fill    :  1);
                    SI_Dimensions := {'d1','d2'};
                    SI_Points := ElementRange(1,PI_NUM_POINTS);  ! {1 .. PI_NUM_POINTS};
                    
                    !PI_Outlier_Probability := 0.0;
                    P_Radius_Noise := PI_Noise;
                    
                    P_miu_Gaussian:=1;
                    P_sigma_Gaussian:=0.3;
                    
                    !for i do
                    !	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    !	P_Angle := radians(360*Uniform(0,1)); ! Generate random 2D angle
                    !	P_Radius_Gaussian:=normal(0,10);
                    !	PI_Point(i, 'd1') := P_Radius_Gaussian*cos(P_Angle);
                    !	PI_Point(i, 'd2') := P_Radius_Gaussian*sin(P_Angle);
                    !endfor;
                    for i do
                    	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    	P_Angle := radians(360*Uniform(0,1)); ! Generate random 2D angle
                    	P_Radius := P_miu_Gaussian;
                    	P_Radius_Gaussian:=normal(0,P_sigma_Gaussian);
                    	PI_Point(i, 'd1') := cos(radians(ord(PE_Class(i))*360/PI_Num_Classes)) + P_Radius_Gaussian;
                    	P_Radius_Gaussian:=normal(0,P_sigma_Gaussian);
                    	PI_Point(i, 'd2') := sin(radians(ord(PE_Class(i))*360/PI_Num_Classes)) + P_Radius_Gaussian;
                    	if ( PI_Outlier_Probability > 0 ) then
                    		if ( Uniform(0,1) < PI_Outlier_Probability ) then
                    			PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes)));
                    		endif;
                    	endif;
                    endfor;
                }
            }
            Procedure gen {
                Body: {
                    P_Radius_Noise := PI_Noise;
                    
                    P_miu_Gaussian:=1;
                    P_sigma_Gaussian:=0.3;
                    
                    !for i do
                    !	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    !	P_Angle := radians(360*Uniform(0,1)); ! Generate random 2D angle
                    !	P_Radius_Gaussian:=normal(0,10);
                    !	PI_Point(i, 'd1') := P_Radius_Gaussian*cos(P_Angle);
                    !	PI_Point(i, 'd2') := P_Radius_Gaussian*sin(P_Angle);
                    !endfor;
                    
                    	PE_Class('001') := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    	P_Angle := radians(360*Uniform(0,1)); ! Generate random 2D angle
                    	P_Radius := P_miu_Gaussian;
                    	P_Radius_Gaussian:=normal(0,P_sigma_Gaussian);
                    	PI_Point('001', 'd1') := cos(radians(ord(PE_Class('001'))*360/PI_Num_Classes)) + P_Radius_Gaussian;
                    	P_Radius_Gaussian:=normal(0,P_sigma_Gaussian);
                    	PI_Point('001', 'd2') := sin(radians(ord(PE_Class('001'))*360/PI_Num_Classes)) + P_Radius_Gaussian;
                    	if ( PI_Outlier_Probability > 0 ) then
                    		if ( Uniform(0,1) < PI_Outlier_Probability ) then
                    			PE_Class('001') := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes)));
                    		endif;
                    	endif;
                }
            }
        }
        Section ANNULUS_2D {
            Procedure Proc_Generate_Random_Instance_Annulus_2D {
                Body: {
                    !PI_NUM_POINTS := 200;
                    !PI_Num_Classes_Annulus2d := 4;
                    SI_Classes := ElementRange(
                    	From    :  1,
                    	To      :  PI_Num_Classes,
                    	Incr    :  1,
                    	Prefix  :  'c',
                    	Fill    :  1);
                    SI_Dimensions := {'d1','d2'};
                    SI_Points := ElementRange(1,PI_NUM_POINTS);  ! {1 .. PI_NUM_POINTS};
                    
                    !PI_Outlier_Probability := 0.0;
                    P_Radius_Noise := PI_Noise;
                    
                    for i do
                    	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    	P_Angle := radians(360*Uniform(0,1)); ! Generate random 2D angle
                    	P_Radius := ord(PE_Class(i)) - P_Radius_Noise/2 + P_Radius_Noise*Uniform(0,1);
                    	PI_Point(i, 'd1') := P_Radius*cos(P_Angle);
                    	PI_Point(i, 'd2') := P_Radius*sin(P_Angle);
                    	if ( PI_Outlier_Probability > 0 ) then
                    		if ( Uniform(0,1) < PI_Outlier_Probability ) then
                    			PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes)));
                    		endif;
                    	endif;
                    endfor;
                }
                Parameter PI_Num_Points_Annulus2d;
                Parameter PI_Num_Classes_Annulus2d {
                    Range: integer;
                }
                Parameter P_Angle;
                Parameter P_Radius {
                    Range: nonnegative;
                }
                Parameter P_Radius_Noise {
                    Range: nonnegative;
                }
            }
            Procedure Proc_Generate_New_Points {
                Body: {
                    
                    !for i_new do
                    !	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    !	P_Angle := radians(360*Uniform(0,1)); ! Generate random 2D angle
                    !	P_Radius := ord(PE_Class(i)) - P_Radius_Noise/2 + P_Radius_Noise*Uniform(0,1);
                    !	PI_Point(i, 'd1') := P_Radius*cos(P_Angle);
                    !	PI_Point(i, 'd2') := P_Radius*sin(P_Angle);
                    !	if ( PI_Outlier_Probability > 0 ) then
                    !		if ( Uniform(0,1) < PI_Outlier_Probability ) then
                    !			PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes)));
                    !		endif;
                    !	endif;
                    !endfor;
                    !
                    !SI_Points := SI_Points + SI_New_Points;
                    !
                }
            }
        }
        Section HEART_2D {
            Procedure Proc_Generate_Random_Instance_Heart_2D {
                Body: {
                    !PI_NUM_POINTS := 200;
                    !PI_Num_Classes_Annulus2d := 4;
                    SI_Classes := ElementRange(
                    	From    :  1,
                    	To      :  PI_Num_Classes,
                    	Incr    :  1,
                    	Prefix  :  'c',
                    	Fill    :  1);
                    SI_Dimensions := {'d1','d2'};
                    SI_Points := ElementRange(1,PI_NUM_POINTS);  ! {1 .. PI_NUM_POINTS};
                    P_Denom := 16;
                    
                    for i do
                    	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    
                    	PI_t := radians(360*Uniform(0,1));
                    
                    !	P_Angle := radians(360*Uniform(0,1)); ! Generate random 2D angle
                    	P_Int := ord(PE_Class(i)); ! - P_Radius_Noise/2 + P_Radius_Noise*Uniform(0,1);
                    
                    	PI_Point(i, 'd1') := (P_Int/P_Denom)*( 16*(sin(PI_t))^3 ) - PI_Noise/2 + PI_Noise*Uniform(0,1);
                    	PI_Point(i, 'd2') := (P_Int/P_Denom)*( 13*cos(PI_t) - 5*cos(2*PI_t) - 2*cos(3*PI_t) - cos(4*PI_t) ) - PI_Noise/2 + PI_Noise*Uniform(0,1);;
                    
                    	if ( PI_Outlier_Probability > 0 ) then
                    		if ( Uniform(0,1) < PI_Outlier_Probability ) then
                    			PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes)));
                    		endif;
                    	endif;
                    endfor;
                }
                Parameter PI_Num_Points_Annulus2d;
                Parameter PI_Num_Classes_Annulus2d {
                    Range: integer;
                }
                Parameter P_Int;
                Parameter PI_t;
                Parameter P_Denom;
            }
        }
        Section STAR_2D {
            Procedure Proc_Generate_Random_Instance_Star_2D {
                Body: {
                    !PI_NUM_POINTS := 200;
                    !PI_Num_Classes_Annulus2d := 4;
                    SI_Classes := ElementRange(
                    	From    :  1,
                    	To      :  PI_Num_Classes,
                    	Incr    :  1,
                    	Prefix  :  'c',
                    	Fill    :  1);
                    SI_Dimensions := {'d1','d2'};
                    SI_Points := ElementRange(1,PI_NUM_POINTS);  ! {1 .. PI_NUM_POINTS};
                    
                    !PI_Outlier_Probability := 0.0;
                    P_Radius_Noise := PI_Noise;
                    
                    for i do
                    	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    	P_Angle := radians(360*Uniform(0,1)); ! Generate random 2D angle
                    	P_Radius := ord(PE_Class(i)) - P_Radius_Noise/2 + P_Radius_Noise*Uniform(0,1);
                    	PI_Point(i, 'd1') := P_Radius*cos(P_Angle);
                    	PI_Point(i, 'd2') := P_Radius*sin(P_Angle);
                    
                    	if ( P_Angle < radians(90) ) then
                    		PI_Point(i, 'd1') -= P_Radius;
                    		PI_Point(i, 'd2') -= P_Radius;
                    	elseif ( radians(90) <= P_Angle and P_Angle < radians(180) ) then
                    		PI_Point(i, 'd1') += P_Radius;
                    		PI_Point(i, 'd2') -= P_Radius;
                    	elseif ( radians(180) <= P_Angle and P_Angle <= radians(270) ) then
                    		PI_Point(i, 'd1') += P_Radius;
                    		PI_Point(i, 'd2') += P_Radius;
                    	else
                    		PI_Point(i, 'd1') -= P_Radius;
                    		PI_Point(i, 'd2') += P_Radius;
                    	endif;
                    
                    	if ( PI_Outlier_Probability > 0 ) then
                    		if ( Uniform(0,1) < PI_Outlier_Probability ) then
                    			PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes)));
                    		endif;
                    	endif;
                    endfor;
                }
                Parameter PI_Num_Points_Annulus2d;
                Parameter PI_Num_Classes_Annulus2d {
                    Range: integer;
                }
                Parameter P_Angle;
                Parameter P_Radius {
                    Range: nonnegative;
                }
                Parameter P_Radius_Noise {
                    Range: nonnegative;
                }
            }
        }
        Section SQUARES_2D {
            Procedure Proc_Generate_Random_Instance_Squares_2D {
                Body: {
                    SI_Classes := ElementRange(
                    	From    :  1,
                    	To      :  PI_Num_Classes,
                    	Incr    :  1,
                    	Prefix  :  'c',
                    	Fill    :  1);
                    SI_Dimensions := {'d1','d2'};
                    SI_Points := ElementRange(1,PI_NUM_POINTS);  ! {1 .. PI_NUM_POINTS};
                    
                    for i do
                    	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    	P_Int := ord(PE_Class(i));
                    	P_Sign := -1;
                    	P_Sign$(Uniform(0,1)<0.5) := 1;
                    	if ( Uniform(0,1) < 0.5 ) then
                    		PI_Point(i, 'd1') := P_Sign*P_Int - PI_Noise/2 + PI_Noise*Uniform(0,1);
                    		PI_Point(i, 'd2') := -P_Int + 2*P_Int*Uniform(0,1);
                    	else
                    		PI_Point(i, 'd1') := -P_Int + 2*P_Int*Uniform(0,1);
                    		PI_Point(i, 'd2') := P_Sign*P_Int - PI_Noise/2 + PI_Noise*Uniform(0,1);
                    	endif;
                    	if ( PI_Outlier_Probability > 0 ) then
                    		if ( Uniform(0,1) < PI_Outlier_Probability ) then
                    			PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes)));
                    		endif;
                    	endif;
                    endfor;
                }
                Parameter P_Sign;
                Parameter P_Int;
            }
        }
        Section DIAMONDS_2D {
            Procedure Proc_Generate_Random_Instance_Diamonds_2D {
                Body: {
                    SI_Classes := ElementRange(
                    	From    :  1,
                    	To      :  PI_Num_Classes,
                    	Incr    :  1,
                    	Prefix  :  'c',
                    	Fill    :  1);
                    SI_Dimensions := {'d1','d2'};
                    SI_Points := ElementRange(1,PI_NUM_POINTS);  ! {1 .. PI_NUM_POINTS};
                    
                    for i do
                    	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    	P_Int := ord(PE_Class(i));
                    	P_Slope_Sign := -1;
                    	P_Slope_Sign$(Uniform(0,1)<0.5) := 1;
                    	P_Intercept_Sign := -1;
                    	P_Intercept_Sign$(Uniform(0,1)<0.5) := 1;
                    
                    	PI_Point(i, 'd1') := P_Slope_Sign*P_Int*Uniform(0,1) - PI_Noise/2 + PI_Noise*Uniform(0,1);
                    	PI_Point(i, 'd2') := P_Intercept_Sign*P_Int - P_Intercept_Sign*P_Slope_Sign*PI_Point(i, 'd1')  - PI_Noise/2 + PI_Noise*Uniform(0,1);
                    
                    	if ( PI_Outlier_Probability > 0 ) then
                    		if ( Uniform(0,1) < PI_Outlier_Probability ) then
                    			PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes)));
                    		endif;
                    	endif;
                    endfor;
                }
                Parameter P_Slope_Sign;
                Parameter P_Intercept_Sign;
                Parameter P_Int;
            }
        }
        Section SINUSOIDS_2D {
            Procedure Proc_Generate_Random_Instance_Sinusoids_2D {
                Body: {
                    !PI_NUM_POINTS := 200;
                    !PI_Num_Classes_Annulus2d := 4;
                    SI_Classes := ElementRange(
                    	From    :  1,
                    	To      :  PI_Num_Classes,
                    	Incr    :  1,
                    	Prefix  :  'c',
                    	Fill    :  1);
                    SI_Dimensions := {'d1','d2'};
                    SI_Points := ElementRange(1,PI_NUM_POINTS);  ! {1 .. PI_NUM_POINTS};
                    
                    !PI_Outlier_Probability := 0.0;
                    P_Y_Noise := PI_Noise;
                    
                    for i do
                    	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    	PI_Point(i, 'd1') := radians(360*Uniform(0,1));
                    	PI_Point(i, 'd2') := ord(PE_Class(i)) + sin(PI_Point(i, 'd1')) + P_Y_Noise*Uniform(0,1) - P_Y_Noise/2;
                    
                    	if ( PI_Outlier_Probability > 0 ) then
                    		if ( Uniform(0,1) < PI_Outlier_Probability ) then
                    			PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes)));
                    		endif;
                    	endif;
                    endfor;
                }
            }
            Parameter PI_Intercept {
                IndexDomain: c;
            }
            Parameter P_Y_Noise;
        }
        Section GMP_RANDOM_2D {
            Procedure Proc_Generate_Random_Instance_2D {
                Body: {
                    SI_Classes := ElementRange(
                    	From    :  1,
                    	To      :  PI_Num_Classes,
                    	Incr    :  1,
                    	Prefix  :  'c',
                    	Fill    :  1);
                    SI_Dimensions := {'d1','d2'};
                    SI_Points := ElementRange(1,PI_NUM_POINTS);  ! {1 .. PI_NUM_POINTS};
                    
                    for i do
                    	PE_Class(i) := Element(SI_Classes, ceil(Uniform(0,1)*Card(SI_Classes))); ! Generate random class
                    	PI_Point(i, 'd1') := 10*Uniform(0,1);
                    	PI_Point(i, 'd2') := 10*Uniform(0,1);
                    endfor;
                }
            }
        }
    }
    Section PLOTTING {
        Procedure Proc_Temp_Get_Outliers {
            Body: {
                !PO_Is_Outlier(i) := 0;
                !PO_Is_Outlier(i)$( PD_L2_Separation(i) < 0 ) := 1;
            }
        }
        Set SI_My_Colors {
            SubsetOf: AllColors;
            Index: i_color;
            OrderBy: User;
            Definition: {
                data{
                'blue'  ,
                'red'   ,
                'dark green' ,
                'grey'  ,
                'green' ,
                'orange' ,
                'pink' ,
                'yellow' ,
                'royal blue' ,
                'magenta' ,
                'cyan' ,
                'navy blue' ,
                'light grey' ,
                'dark grey' ,
                'yukon yellow' ,
                'icelandic brown' ,
                'quebec pink' ,
                'pygmy maroon' ,
                'carolina blue' ,
                'pygmy pink' ,
                'mexican purple' ,
                'dark cyan' ,
                'hawaiian grey' ,
                'yemeni blue' ,
                'pygmy yellow' ,
                'venezuelan brown' ,
                'ugandan pink'
                }
            }
        }
        ElementParameter PE_Class_Color {
            IndexDomain: c;
            Range: SI_My_Colors;
            Definition: {
                
                Element(SI_My_Colors,ord(c))
            }
        }
        ElementParameter PE_Color {
            IndexDomain: i;
            Range: SI_My_Colors;
            Definition: {
                
                PE_Class_Color( PE_Class(i) )
            }
        }
        Parameter PI_X_Coord {
            IndexDomain: i;
            Range: free;
            Definition: {
                
                PI_Point(i, First(SI_Dimensions))
            }
        }
        Parameter PI_Y_Coord {
            IndexDomain: i;
            Range: free;
            Definition: {
                
                PI_Point(i, Last(SI_Dimensions))
            }
        }
        Set SI_My_Shapes {
            Index: i_shape;
            OrderBy: User;
            Definition: {
                data{
                'x'  ,
                'o'  ,
                '.'  ,
                '-'  ,
                '^'  ,
                '*'
                }
            }
        }
        ElementParameter PE_Class_Shape {
            IndexDomain: c;
            Range: SI_My_Shapes;
            Definition: {
                
                Element(SI_My_Shapes,ord(c))
            }
        }
        ElementParameter PE_Shape {
            IndexDomain: i;
            Range: SI_My_Shapes;
            Definition: {
                
                PE_Class_Shape( PE_Class(i) )
            }
        }
        StringParameter PS_Shape {
            IndexDomain: i;
            Definition: {
                
                PE_Shape(i)
            }
        }
        Parameter PI_Node_Size {
            Range: integer;
            InitialData: 10;
        }
        Set SI_Plot_Points {
            SubsetOf: Integers;
            Index: i_plot;
            Definition: {
                
                {1..PI_Num_Dist_Metric_Plot_Points}
            }
        }
        Parameter PI_Num_Dist_Metric_Plot_Points {
            Range: integer;
            Definition: 100;
        }
        Parameter PI_Plot_Angle {
            IndexDomain: i_plot;
            Definition: {
                
                radians( 360*(ord(i_plot)-1)/PI_Num_Dist_Metric_Plot_Points  )
            }
        }
        Parameter PI_Unit_Circle_Plot_Point {
            IndexDomain: (i_plot,d);
            Definition: {
                
                if ( d = First(SI_Dimensions) ) then
                	cos( PI_Plot_Angle(i_plot) )
                else
                	sin( PI_Plot_Angle(i_plot) )
                endif;
            }
        }
        Parameter PD_Dist_Metric_Plot_Point {
            IndexDomain: (i_plot,d);
            Definition: {
                !TODO 2016/10/7
                
                sum[ d2 , PO_Q_Coeff(d, d2) * PI_Unit_Circle_Plot_Point(i_plot, d2) ]
            }
        }
        DeclarationSection Plotting_Declarations_with_Solution {
            Parameter PD_LP_Solution_Node_Size {
                IndexDomain: i;
                Definition: {
                    if ( not PO_Is_LP_Outlier(i) ) then
                    	PI_Node_Size
                    else
                    	PI_Outlier_Node_Size
                    endif;
                }
            }
            Set SD_Outlier_Points {
                SubsetOf: SI_Points;
                Index: i_outlier;
                Definition: {
                    
                    { i | PO_Is_Outlier(i) }
                }
            }
            Set SD_LP_Outlier_Points {
                SubsetOf: SI_Points;
                Index: i_LP_outlier;
                Definition: {
                    
                    { i_a | PO_Is_LP_Outlier(i_a) }
                }
            }
            Set SD_Non_Outlier_Points {
                SubsetOf: SI_Points;
                Index: i_non_outlier;
                Definition: {
                    
                    SI_Points - SD_Outlier_Points
                }
            }
            Set SD_LP_Non_Outlier_Points {
                SubsetOf: SI_Points;
                Index: i_LP_non_outlier;
                Definition: {
                    
                    SI_Points_Active - SD_LP_Outlier_Points
                }
            }
            Set SD_Outlier_Arcs {
                SubsetOf: (SD_Outlier_Points,SI_Points);
                Definition: {
                    
                    { (i_outlier,j) | j = argmin[ k | (i_outlier,k) in SD_Non_Neighbors , PD_L2_Distance(i_outlier, k) ] }
                }
            }
            ElementParameter PE_Outlier_Color {
                Range: AllColors;
                Definition: 'black';
            }
            ElementParameter PE_Solution_Color {
                IndexDomain: i;
                Range: SI_My_Colors;
                Definition: {
                    PE_Class_Color( PE_Class(i) )
                    
                    !if ( not PO_Is_Outlier(i) ) then
                    !	PE_Class_Color( PE_Class(i) )
                    !else
                    !	PE_Outlier_Color
                    !endif;
                }
            }
            Parameter PO_VB_Is_Outlier {
                IndexDomain: i;
                Range: binary;
                Definition: {
                    
                    round( VB_Is_Outlier(i) )
                }
            }
            Parameter PO_Is_Outlier {
                IndexDomain: i;
                Range: binary;
                Definition: {
                    if ( PD_L2_Separation(i) < 0 ) then
                    	1
                    else
                    	0
                    endif;
                }
                Comment: "to do change PD_L2 to a distance metrix";
            }
            Parameter PI_Outlier_Node_Size {
                Range: integer;
                Definition: PI_Node_Size + 5;
            }
            Parameter PD_Solution_Node_Size {
                IndexDomain: i;
                Range: integer;
                Definition: {
                    if ( not PO_Is_Outlier(i) ) then
                    	PI_Node_Size
                    else
                    	PI_Outlier_Node_Size
                    endif;
                }
            }
        }
        DeclarationSection Objective_Function_Options {
            Set SD_Separation_Values {
                Definition: {
                    
                    {
                    -1.0,
                    -0.9,
                    -0.8,
                    -0.7,
                    -0.6,
                    -0.5,
                    -0.4,
                    -0.3,
                    -0.2,
                    -0.1,
                    -0.09,
                    0.01,
                    0.02,
                    0.03,
                    0.04,
                    0.05,
                    0.06,
                    0.07,
                    0.08,
                    0.09,
                    0.1,
                    0.2,
                    0.3,
                    0.4,
                    0.5,
                    0.6,
                    0.7,
                    0.8,
                    0.9,
                    1.0
                    }
                }
            }
            Set SQS {
                SubsetOf: Integers;
                Index: i_sep_incr;
                Definition: {
                    
                    ElementRange(1,201);
                }
            }
            Parameter PI_X_Axis_Plot_Objval {
                IndexDomain: i_sep_incr;
                Definition: {
                    
                    -1 + 0.01*(i_sep_incr-1)
                }
            }
            Parameter PD_Y_Axis_Plot_Objval_Tanh {
                IndexDomain: i_sep_incr;
                Definition: {
                    
                    !-0.5 + 1/(1+exp(-PI_X_Axis_Plot_Objval(i_sep_incr)))
                    tanh(4*PI_X_Axis_Plot_Objval(i_sep_incr))
                }
            }
            Parameter PD_Y_Axis_Plot_Objval_PWL {
                IndexDomain: i_sep_incr;
                Definition: {
                    if ( PI_X_Axis_Plot_Objval(i_sep_incr) < 0 ) then
                    	-1
                    else
                    	PI_X_Axis_Plot_Objval(i_sep_incr)
                    endif;
                }
            }
            Parameter PD_Y_Axis_Plot_Objval_PWL2 {
                IndexDomain: i_sep_incr;
                Definition: {
                    if ( PI_X_Axis_Plot_Objval(i_sep_incr) < 0 ) then
                    	-1
                    elseif ( 0 <= PI_X_Axis_Plot_Objval(i_sep_incr) and PI_X_Axis_Plot_Objval(i_sep_incr) < 0.5 ) then
                    	PI_X_Axis_Plot_Objval(i_sep_incr)
                    else
                    	0.5
                    endif;
                }
            }
        }
    }
    Section UTILS {
        Procedure Proc_Normalize_Data {
            Body: {
                
                PI_Point(i, d) := ( PI_Point(i, d) - PD_Min_Coord ) / ( PD_Max_Coord - PD_Min_Coord )
            }
        }
    }
    Module TempModule {
        Prefix: tm;
        Section Section_1 {
            Procedure Solve_MP1 {
                Body: {
                    solve MP1;
                }
            }
            Procedure Get_presolved_model {
                Body: {
                    PE_GMP_MP1 := GMP::Instance::Generate( MP1 );
                    PE_GMP_MP1_Presolved := GMP::Instance::CreatePresolved( PE_GMP_MP1 , "Presolved_MP1_Model" );
                    PD_Num_Rows_Presolved := GMP::Instance::GetNumberOfRows( PE_GMP_MP1_Presolved );
                    PD_Num_Cols_Presolved := GMP::Instance::GetNumberOfColumns( PE_GMP_MP1_Presolved );
                    !GMP::Instance::GetSymbolicMathematicalProgram
                }
            }
            Set SI_N {
                SubsetOf: Integers;
                Index: j;
                Definition: {
                    {1,2}
                }
            }
            Variable x {
                IndexDomain: j;
                Range: nonnegative;
            }
            Variable objval {
                Range: free;
                Definition: 2*x(1) + x(2);
            }
            Constraint Constraint1 {
                Definition: x(1) + x(2) <= 1;
            }
            Constraint Constraint2 {
                Definition: x(1) + x(2) <= 10;
            }
            MathematicalProgram MP1 {
                Objective: objval;
                Direction: maximize;
                Constraints: SD_Temp_Constraints;
                Variables: SD_Temp_Variables;
                Type: Automatic;
            }
            Set SD_Temp_Variables {
                SubsetOf: AllVariables;
                Definition: AllVariables * Section_1;
            }
            Set SD_Temp_Constraints {
                SubsetOf: AllConstraints;
                Definition: AllConstraints * Section_1;
            }
            ElementParameter PE_GMP_MP1 {
                Range: AllGeneratedMathematicalPrograms;
            }
            ElementParameter PE_GMP_MP1_Presolved {
                Range: AllGeneratedMathematicalPrograms;
            }
            Parameter PD_Num_Rows_Presolved;
            Parameter PD_Num_Cols_Presolved;
        }
    }
    Procedure MainInitialization {
        Body: {
            !SI_Points := {1,2};
            !SI_Classes := {1};
            !SI_Dimension := {1,2};
            !
            !PI_Point(i,d) := ord(d)-1;
            
            !(1,1), (1,0), (2,2) , (2,0),
        }
    }
    Procedure MainExecution;
    Procedure MainTermination {
        Body: {
            return DataManagementExit();
        }
    }
}
